---
uid: web-forms/overview/data-access/caching-data/caching-data-in-the-architecture-vb
title: Buforowanie danych w architekturze (VB) | Dokumentacja firmy Microsoft
author: rick-anderson
description: W poprzednim samouczku dowiedzieliśmy sposobu stosowania pamięci podręcznej w warstwie prezentacji. W tym samouczku będziemy Dowiedz się, jak korzystać z zalet naszej warstwowej architectu...
ms.author: riande
ms.date: 05/30/2007
ms.assetid: 5e189dd7-f4f9-4f28-9b3a-6cb7d392e9c7
msc.legacyurl: /web-forms/overview/data-access/caching-data/caching-data-in-the-architecture-vb
msc.type: authoredcontent
ms.openlocfilehash: 9c5ac1aeff427c78030f789fcb67736020ce3367
ms.sourcegitcommit: 0f1119340e4464720cfd16d0ff15764746ea1fea
ms.translationtype: MT
ms.contentlocale: pl-PL
ms.lasthandoff: 04/09/2019
ms.locfileid: "59391809"
---
# <a name="caching-data-in-the-architecture-vb"></a><span data-ttu-id="00e60-104">Buforowanie danych w architekturze (VB)</span><span class="sxs-lookup"><span data-stu-id="00e60-104">Caching Data in the Architecture (VB)</span></span>

<span data-ttu-id="00e60-105">przez [Bento Scott](https://twitter.com/ScottOnWriting)</span><span class="sxs-lookup"><span data-stu-id="00e60-105">by [Scott Mitchell](https://twitter.com/ScottOnWriting)</span></span>

<span data-ttu-id="00e60-106">[Pobierz przykładową aplikację](http://download.microsoft.com/download/4/a/7/4a7a3b18-d80e-4014-8e53-a6a2427f0d93/ASPNET_Data_Tutorial_59_VB.exe) lub [Pobierz plik PDF](caching-data-in-the-architecture-vb/_static/datatutorial59vb1.pdf)</span><span class="sxs-lookup"><span data-stu-id="00e60-106">[Download Sample App](http://download.microsoft.com/download/4/a/7/4a7a3b18-d80e-4014-8e53-a6a2427f0d93/ASPNET_Data_Tutorial_59_VB.exe) or [Download PDF](caching-data-in-the-architecture-vb/_static/datatutorial59vb1.pdf)</span></span>

> <span data-ttu-id="00e60-107">W poprzednim samouczku dowiedzieliśmy sposobu stosowania pamięci podręcznej w warstwie prezentacji.</span><span class="sxs-lookup"><span data-stu-id="00e60-107">In the previous tutorial we learned how to apply caching at the Presentation Layer.</span></span> <span data-ttu-id="00e60-108">W tym samouczku będziemy Dowiedz się, jak korzystać z zalet naszej architektury warstwowej pamięci podręcznej danych na warstwę logiki biznesowej.</span><span class="sxs-lookup"><span data-stu-id="00e60-108">In this tutorial we learn how to take advantage of our layered architecture to cache data at the Business Logic Layer.</span></span> <span data-ttu-id="00e60-109">Możemy to zrobić, rozszerzenie architektury obejmujący warstwy pamięci podręcznej.</span><span class="sxs-lookup"><span data-stu-id="00e60-109">We do this by extending the architecture to include a Caching Layer.</span></span>


## <a name="introduction"></a><span data-ttu-id="00e60-110">Wprowadzenie</span><span class="sxs-lookup"><span data-stu-id="00e60-110">Introduction</span></span>

<span data-ttu-id="00e60-111">Jak widzieliśmy w poprzednim samouczku, buforowanie danych s ObjectDataSource jest tak proste, jak ustawienie kilka właściwości.</span><span class="sxs-lookup"><span data-stu-id="00e60-111">As we saw in the preceding tutorial, caching the ObjectDataSource s data is as simple as setting a couple of properties.</span></span> <span data-ttu-id="00e60-112">Niestety kontrolki ObjectDataSource ma zastosowanie, pamięć podręczna w warstwie prezentacji, składającą się ściśle zasad buforowania strony ASP.NET.</span><span class="sxs-lookup"><span data-stu-id="00e60-112">Unfortunately, the ObjectDataSource applies caching at the Presentation Layer, which tightly couples the caching policies with the ASP.NET page.</span></span> <span data-ttu-id="00e60-113">Jest jednym z powodów tworzenia architektury warstwowej umożliwia takie sprzężenia podzielone.</span><span class="sxs-lookup"><span data-stu-id="00e60-113">One of the reasons for creating a layered architecture is to allow such couplings to be broken.</span></span> <span data-ttu-id="00e60-114">Warstwy logiki biznesowej, na przykład oddziela logiki biznesowej na stronach ASP.NET, podczas gdy warstwa dostępu do danych oddziela szczegóły dostępu do danych.</span><span class="sxs-lookup"><span data-stu-id="00e60-114">The Business Logic Layer, for instance, decouples the business logic from the ASP.NET pages, while the Data Access Layer decouples the data access details.</span></span> <span data-ttu-id="00e60-115">To oddzielenie szczegóły dostępu logikę i dane biznesowe jest preferowane, w całości, ponieważ jego system staje się bardziej czytelny, będzie łatwiejszy w utrzymaniu i bardziej elastyczne zmiany.</span><span class="sxs-lookup"><span data-stu-id="00e60-115">This decoupling of business logic and data access details is preferred, in part, because it makes the system more readable, more maintainable, and more flexible to change.</span></span> <span data-ttu-id="00e60-116">Pozwala także wiedzy specjalistycznej i dzielenie liczb pracy dewelopera nad Warstwa prezentacji t trzeba należy zapoznać się ze szczegółami s bazy danych w celu wykonywania swojej pracy.</span><span class="sxs-lookup"><span data-stu-id="00e60-116">It also allows for domain knowledge and division of labor a developer working on the Presentation Layer doesn t need to be familiar with the database s details in order to do her job.</span></span> <span data-ttu-id="00e60-117">Oddzielenie zasad pamięci podręcznej z warstwy prezentacji oferuje podobne korzyści.</span><span class="sxs-lookup"><span data-stu-id="00e60-117">Decoupling the caching policy from the Presentation Layer offers similar benefits.</span></span>

<span data-ttu-id="00e60-118">W tym samouczku będziemy rozszerzać naszej architektury, aby uwzględnić *warstwy buforowania* (lub CL w skrócie) który wykorzystuje nasze zasady buforowania.</span><span class="sxs-lookup"><span data-stu-id="00e60-118">In this tutorial we will augment our architecture to include a *Caching Layer* (or CL for short) that employs our caching policy.</span></span> <span data-ttu-id="00e60-119">Warstwy buforowania będzie zawierać `ProductsCL` klasy, która zapewnia dostęp do informacji o produkcie przy użyciu metod, takich jak `GetProducts()`, `GetProductsByCategoryID(categoryID)`, i tak dalej, aby po wywołaniu, będzie pierwsza próba pobrania danych z pamięci podręcznej.</span><span class="sxs-lookup"><span data-stu-id="00e60-119">The Caching Layer will include a `ProductsCL` class that provides access to product information with methods like `GetProducts()`, `GetProductsByCategoryID(categoryID)`, and so forth, that, when invoked, will first attempt to retrieve the data from the cache.</span></span> <span data-ttu-id="00e60-120">Jeśli pamięć podręczna jest pusta, te metody wywoła odpowiednie `ProductsBLL` metody w LOGIKI, która z kolei może pobrać danych z warstwy DAL.</span><span class="sxs-lookup"><span data-stu-id="00e60-120">If the cache is empty, these methods will invoke the appropriate `ProductsBLL` method in the BLL, which would in turn get the data from the DAL.</span></span> <span data-ttu-id="00e60-121">`ProductsCL` Metod w pamięci podręcznej danych pobranych z LOGIKI przed zwróceniem.</span><span class="sxs-lookup"><span data-stu-id="00e60-121">The `ProductsCL` methods cache the data retrieved from the BLL before returning it.</span></span>

<span data-ttu-id="00e60-122">Jak pokazano na rysunku 1, CL znajduje się między prezentacji i warstwy logiki biznesowej.</span><span class="sxs-lookup"><span data-stu-id="00e60-122">As Figure 1 shows, the CL resides between the Presentation and Business Logic Layers.</span></span>


![Warstwy pamięci podręcznej (CL) jest kolejną warstwę w nasze architektury](caching-data-in-the-architecture-vb/_static/image1.png)

<span data-ttu-id="00e60-124">**Rysunek 1**: Warstwy pamięci podręcznej (CL) jest kolejną warstwę w nasze architektury</span><span class="sxs-lookup"><span data-stu-id="00e60-124">**Figure 1**: The Caching Layer (CL) is Another Layer in Our Architecture</span></span>


## <a name="step-1-creating-the-caching-layer-classes"></a><span data-ttu-id="00e60-125">Krok 1. Tworzenie pamięci podręcznej klas warstwy</span><span class="sxs-lookup"><span data-stu-id="00e60-125">Step 1: Creating the Caching Layer Classes</span></span>

<span data-ttu-id="00e60-126">W tym samouczku utworzymy bardzo prosty CL, za pomocą jednej klasy `ProductsCL` zawierający tylko kilku metod.</span><span class="sxs-lookup"><span data-stu-id="00e60-126">In this tutorial we will create a very simple CL with a single class `ProductsCL` that has only a handful of methods.</span></span> <span data-ttu-id="00e60-127">Tworzenie pełną warstwy buforowania dla całej aplikacji wymaga tworzenia `CategoriesCL`, `EmployeesCL`, i `SuppliersCL` klasy i udostępnieniu metod w klasach te warstwy buforowania dla każdego dostępu lub modyfikacji metody danych w LOGIKI.</span><span class="sxs-lookup"><span data-stu-id="00e60-127">Building a complete Caching Layer for the entire application would require creating `CategoriesCL`, `EmployeesCL`, and `SuppliersCL` classes, and providing a method in these Caching Layer classes for each data access or modification method in the BLL.</span></span> <span data-ttu-id="00e60-128">Podobnie jak w przypadku LOGIKI i warstwy DAL, warstwy buforowania najlepiej powinny zostać wdrożone jako oddzielny projekt biblioteki klas; Jednak firma Microsoft wdroży go jako klasa w `App_Code` folderu.</span><span class="sxs-lookup"><span data-stu-id="00e60-128">As with the BLL and DAL, the Caching Layer should ideally be implemented as a separate Class Library project; however, we will implement it as a class in the `App_Code` folder.</span></span>

<span data-ttu-id="00e60-129">Do innych klas klarownie oddzielne CL z klas DAL i logiki warstwy Biznesowej umożliwiają s Utwórz nowy podfolder w `App_Code` folderu.</span><span class="sxs-lookup"><span data-stu-id="00e60-129">To more cleanly separate the CL classes from the DAL and BLL classes, let s create a new subfolder in the `App_Code` folder.</span></span> <span data-ttu-id="00e60-130">Kliknij prawym przyciskiem myszy `App_Code` folder w Eksploratorze rozwiązań wybierz nowy Folder i nazwę nowego folderu `CL`.</span><span class="sxs-lookup"><span data-stu-id="00e60-130">Right-click on the `App_Code` folder in the Solution Explorer, choose New Folder, and name the new folder `CL`.</span></span> <span data-ttu-id="00e60-131">Po utworzeniu tego folderu, Dodaj do niej nową klasę o nazwie `ProductsCL.vb`.</span><span class="sxs-lookup"><span data-stu-id="00e60-131">After creating this folder, add to it a new class named `ProductsCL.vb`.</span></span>


![Dodaj nowy Folder o nazwie CL i klasę o nazwie ProductsCL.vb](caching-data-in-the-architecture-vb/_static/image2.png)

<span data-ttu-id="00e60-133">**Rysunek 2**: Dodaj nowy Folder o nazwie `CL` i klasę o nazwie</span><span class="sxs-lookup"><span data-stu-id="00e60-133">**Figure 2**: Add a New Folder Named `CL` and a Class Named</span></span> `ProductsCL.vb`


<span data-ttu-id="00e60-134">`ProductsCL` Klasy powinna zawierać ten sam zestaw metod dostępu i modyfikowanie danych tak jak w programie klasą odpowiedniej warstwy logiki biznesowej (`ProductsBLL`).</span><span class="sxs-lookup"><span data-stu-id="00e60-134">The `ProductsCL` class should include the same set of data access and modification methods as found in its corresponding Business Logic Layer class (`ProductsBLL`).</span></span> <span data-ttu-id="00e60-135">Zamiast tworzenia wszystkie te metody pozwalają s kompilacji tylko kilka tutaj, aby można było uzyskać pewne pojęcie wzorców posługują się CL.</span><span class="sxs-lookup"><span data-stu-id="00e60-135">Rather than creating all of these methods, let s just build a couple here to get a feel for the patterns used by the CL.</span></span> <span data-ttu-id="00e60-136">W szczególności, dodamy `GetProducts()` i `GetProductsByCategoryID(categoryID)` metod w kroku 3 i `UpdateProduct` przeciążenia w kroku 4.</span><span class="sxs-lookup"><span data-stu-id="00e60-136">In particular, we'll add the `GetProducts()` and `GetProductsByCategoryID(categoryID)` methods in Step 3 and an `UpdateProduct` overload in Step 4.</span></span> <span data-ttu-id="00e60-137">Możesz dodać pozostałe `ProductsCL` metod i `CategoriesCL`, `EmployeesCL`, i `SuppliersCL` klas w wolnym czasie.</span><span class="sxs-lookup"><span data-stu-id="00e60-137">You can add the remaining `ProductsCL` methods and `CategoriesCL`, `EmployeesCL`, and `SuppliersCL` classes at your leisure.</span></span>

## <a name="step-2-reading-and-writing-to-the-data-cache"></a><span data-ttu-id="00e60-138">Krok 2. Odczytywanie i zapisywanie w pamięci podręcznej danych</span><span class="sxs-lookup"><span data-stu-id="00e60-138">Step 2: Reading and Writing to the Data Cache</span></span>

<span data-ttu-id="00e60-139">Kontrolki ObjectDataSource przedstawione w poprzednim samouczku wewnętrznie funkcję buforowania używa pamięci podręcznej danych ASP.NET do przechowywania danych pobranych z LOGIKI.</span><span class="sxs-lookup"><span data-stu-id="00e60-139">The ObjectDataSource caching feature explored in the preceding tutorial internally uses the ASP.NET data cache to store the data retrieved from the BLL.</span></span> <span data-ttu-id="00e60-140">Pamięć podręczna danych również są dostępne programowo z klasy CodeBehind stron ASP.NET lub klas w ramach architektury s dla aplikacji sieci web.</span><span class="sxs-lookup"><span data-stu-id="00e60-140">The data cache can also be accessed programmatically from ASP.NET pages code-behind classes or from the classes in the web application s architecture.</span></span> <span data-ttu-id="00e60-141">Aby do odczytu i zapisu pamięci podręcznej danych z klasy CodeBehind s strony ASP.NET, należy użyć następującego wzorca:</span><span class="sxs-lookup"><span data-stu-id="00e60-141">To read and write to the data cache from an ASP.NET page s code-behind class, use the following pattern:</span></span>


[!code-vb[Main](caching-data-in-the-architecture-vb/samples/sample1.vb)]

<span data-ttu-id="00e60-142">[ `Cache` Klasy](https://msdn.microsoft.com/library/system.web.caching.cache.aspx) s [ `Insert` metoda](https://msdn.microsoft.com/library/system.web.caching.cache.insert.aspx) ma kilka przeciążeń.</span><span class="sxs-lookup"><span data-stu-id="00e60-142">The [`Cache` class](https://msdn.microsoft.com/library/system.web.caching.cache.aspx) s [`Insert` method](https://msdn.microsoft.com/library/system.web.caching.cache.insert.aspx) has a number of overloads.</span></span> `Cache("key") = value` <span data-ttu-id="00e60-143">i `Cache.Insert(key, value)` oznaczają to samo i zarówno dodania elementu do pamięci podręcznej przy użyciu określonego klucza bez zdefiniowanego wygaśnięcia.</span><span class="sxs-lookup"><span data-stu-id="00e60-143">and `Cache.Insert(key, value)` are synonymous and both add an item to the cache using the specified key without a defined expiry.</span></span> <span data-ttu-id="00e60-144">Zazwyczaj chcemy określić wygaśnięcia, podczas dodawania elementu do pamięci podręcznej, jako zależność i/lub na podstawie czasu wygaśnięcia.</span><span class="sxs-lookup"><span data-stu-id="00e60-144">Typically, we want to specify an expiry when adding an item to the cache, either as a dependency, a time-based expiry, or both.</span></span> <span data-ttu-id="00e60-145">Użyj jednego z innych `Insert` przeciążenia metody s, aby podać informacje na podstawie zależności lub do czasu wygaśnięcia.</span><span class="sxs-lookup"><span data-stu-id="00e60-145">Use one of the other `Insert` method s overloads to provide dependency- or time-based expiry information.</span></span>

<span data-ttu-id="00e60-146">Warstwy buforowania, s metody, należy najpierw sprawdzić, jeśli żądanych danych znajduje się w pamięci podręcznej, a jeśli tak, przywrócić go z tego miejsca.</span><span class="sxs-lookup"><span data-stu-id="00e60-146">The Caching Layer s methods need to first check if the requested data is in the cache and, if so, return it from there.</span></span> <span data-ttu-id="00e60-147">Jeśli żądanych danych nie jest w pamięci podręcznej, musi być wywoływane odpowiedniej metody LOGIKI.</span><span class="sxs-lookup"><span data-stu-id="00e60-147">If the requested data is not in the cache, the appropriate BLL method needs to be invoked.</span></span> <span data-ttu-id="00e60-148">Wartość zwracaną powinien pamięci podręcznej, a następnie wróciło, tak jak pokazano na poniższym diagramie sekwencji.</span><span class="sxs-lookup"><span data-stu-id="00e60-148">Its return value should be cached and then returned, as the following sequence diagram illustrates.</span></span>


![Metody s warstwy buforowania zwracają dane z pamięci podręcznej, jeśli jego s dostępne](caching-data-in-the-architecture-vb/_static/image3.png)

<span data-ttu-id="00e60-150">**Rysunek 3**: Metody s warstwy buforowania zwracają dane z pamięci podręcznej, jeśli jego s dostępne</span><span class="sxs-lookup"><span data-stu-id="00e60-150">**Figure 3**: The Caching Layer s Methods Return Data from the Cache if it s Available</span></span>


<span data-ttu-id="00e60-151">Sekwencja przedstawione na rysunku 3 odbywa się w klasach CL, przy użyciu następującego wzorca:</span><span class="sxs-lookup"><span data-stu-id="00e60-151">The sequence depicted in Figure 3 is accomplished in the CL classes using the following pattern:</span></span>


[!code-vb[Main](caching-data-in-the-architecture-vb/samples/sample2.vb)]

<span data-ttu-id="00e60-152">W tym miejscu *typu* jest typem danych znajdujących się w pamięci podręcznej `Northwind.ProductsDataTable`, na przykład *klucza* jest klucz, który unikatowo identyfikuje element pamięci podręcznej.</span><span class="sxs-lookup"><span data-stu-id="00e60-152">Here, *Type* is the type of data being stored in the cache `Northwind.ProductsDataTable`, for example while *key* is the key that uniquely identifies the cache item.</span></span> <span data-ttu-id="00e60-153">Jeśli element z określonym *klucz* nie znajduje się w pamięci podręcznej, następnie *wystąpienia* będzie `Nothing` i dane zostaną pobrane z odpowiedniej metody LOGIKI i dodane do pamięci podręcznej.</span><span class="sxs-lookup"><span data-stu-id="00e60-153">If the item with the specified *key* is not in the cache, then *instance* will be `Nothing` and the data will be retrieved from the appropriate BLL method and added to the cache.</span></span> <span data-ttu-id="00e60-154">Do czasu `Return instance` osiągnięciu *wystąpienia* zawiera odwołanie do danych z pamięci podręcznej lub pobierane z LOGIKI.</span><span class="sxs-lookup"><span data-stu-id="00e60-154">By the time `Return instance` is reached, *instance* contains a reference to the data, either from the cache or pulled from the BLL.</span></span>

<span data-ttu-id="00e60-155">Pamiętaj użyć wzorca powyżej, podczas uzyskiwania dostępu do danych z pamięci podręcznej.</span><span class="sxs-lookup"><span data-stu-id="00e60-155">Be sure to use the above pattern when accessing data from the cache.</span></span> <span data-ttu-id="00e60-156">Następujący wzorzec, które na pierwszy rzut oka wygląda równoważnej zawiera niewielka różnica, która wprowadza sytuacji wyścigu.</span><span class="sxs-lookup"><span data-stu-id="00e60-156">The following pattern, which, at first glance, looks equivalent, contains a subtle difference that introduces a race condition.</span></span> <span data-ttu-id="00e60-157">Warunki wyścigu są trudne do debugowania, ponieważ ujawniają się sporadycznie i są trudne do odtworzenia.</span><span class="sxs-lookup"><span data-stu-id="00e60-157">Race conditions are difficult to debug because they reveal themselves sporadically and are difficult to reproduce.</span></span>


[!code-vb[Main](caching-data-in-the-architecture-vb/samples/sample3.vb)]

<span data-ttu-id="00e60-158">Różnica ta sekunda, niepoprawny kod fragment jest fakt, że zamiast przechowywania odwołanie do elementu pamięci podręcznej w zmiennej lokalnej, pamięć podręczną danych odbywa się bezpośrednio w instrukcji warunkowej *i* w `Return`.</span><span class="sxs-lookup"><span data-stu-id="00e60-158">The difference in this second, incorrect code snippet is that rather than storing a reference to the cached item in a local variable, the data cache is accessed directly in the conditional statement *and* in the `Return`.</span></span> <span data-ttu-id="00e60-159">Załóżmy, że po osiągnięciu tego kodu `Cache("key")` nie `Nothing`, lecz przed `Return` osiągnięta zostanie instrukcja, wyklucza systemu mogą *klucz* z pamięci podręcznej.</span><span class="sxs-lookup"><span data-stu-id="00e60-159">Imagine that when this code is reached, `Cache("key")` is not `Nothing`, but before the `Return` statement is reached, the system evicts *key* from the cache.</span></span> <span data-ttu-id="00e60-160">W tym przypadku rzadkich zwróci kod `Nothing` zamiast obiektu oczekiwanego typu.</span><span class="sxs-lookup"><span data-stu-id="00e60-160">In this rare case, the code will return `Nothing` rather than an object of the expected type.</span></span>

> [!NOTE]
> <span data-ttu-id="00e60-161">Pamięć podręczna danych jest bezpieczna dla wątków, więc nie trzeba do synchronizowania dostępu wątku dla proste operacje odczytu i zapisu.</span><span class="sxs-lookup"><span data-stu-id="00e60-161">The data cache is thread-safe, so you don't need to synchronize thread access for simple reads or writes.</span></span> <span data-ttu-id="00e60-162">Jednakże jeśli musisz wykonać wiele operacji na danych w pamięci podręcznej, które muszą być niepodzielną ponosisz odpowiedzialność za Implementowanie blokady lub inny mechanizm w celu zapewnienia bezpieczeństwa wątków.</span><span class="sxs-lookup"><span data-stu-id="00e60-162">However, if you need to perform multiple operations on data in the cache that need to be atomic, you are responsible for implementing a lock or some other mechanism to ensure thread safety.</span></span> <span data-ttu-id="00e60-163">Zobacz [synchronizowania dostępu do pamięci podręcznej platformy ASP.NET](http://www.ddj.com/184406369) Aby uzyskać więcej informacji.</span><span class="sxs-lookup"><span data-stu-id="00e60-163">See [Synchronizing Access to the ASP.NET Cache](http://www.ddj.com/184406369) for more information.</span></span>


<span data-ttu-id="00e60-164">Element może zostać programowo wykluczony z pamięci podręcznej danych przy użyciu [ `Remove` metoda](https://msdn.microsoft.com/library/system.web.caching.cache.remove.aspx) w następujący sposób:</span><span class="sxs-lookup"><span data-stu-id="00e60-164">An item can be programmatically evicted from the data cache using the [`Remove` method](https://msdn.microsoft.com/library/system.web.caching.cache.remove.aspx) like so:</span></span>


[!code-vb[Main](caching-data-in-the-architecture-vb/samples/sample4.vb)]

## <a name="step-3-returning-product-information-from-theproductsclclass"></a><span data-ttu-id="00e60-165">Krok 3. Zwraca informacje o produkcie z`ProductsCL`klasy</span><span class="sxs-lookup"><span data-stu-id="00e60-165">Step 3: Returning Product Information from the`ProductsCL`Class</span></span>

<span data-ttu-id="00e60-166">Dla tego samouczka umożliwiają s implementacji dwóch metod do zwracania informacji o produkcie z `ProductsCL` klasy: `GetProducts()` i `GetProductsByCategoryID(categoryID)`.</span><span class="sxs-lookup"><span data-stu-id="00e60-166">For this tutorial let s implement two methods for returning product information from the `ProductsCL` class: `GetProducts()` and `GetProductsByCategoryID(categoryID)`.</span></span> <span data-ttu-id="00e60-167">Za pomocą `ProductsBL` klasy w warstwę logiki biznesowej `GetProducts()` metody w CL zwraca informacje dotyczące wszystkich produktów jako `Northwind.ProductsDataTable` obiektu, podczas gdy `GetProductsByCategoryID(categoryID)` zwraca wszystkie produkty z określonej kategorii.</span><span class="sxs-lookup"><span data-stu-id="00e60-167">Like with the `ProductsBL` class in the Business Logic Layer, the `GetProducts()` method in the CL returns information about all of the products as a `Northwind.ProductsDataTable` object, while `GetProductsByCategoryID(categoryID)` returns all of the products from a specified category.</span></span>

<span data-ttu-id="00e60-168">Poniższy kod ilustruje część metody w `ProductsCL` klasy:</span><span class="sxs-lookup"><span data-stu-id="00e60-168">The following code shows a portion of the methods in the `ProductsCL` class:</span></span>


[!code-vb[Main](caching-data-in-the-architecture-vb/samples/sample5.vb)]

<span data-ttu-id="00e60-169">Najpierw należy zanotować `DataObject` i `DataObjectMethodAttribute` atrybuty stosowane do klasy i metody.</span><span class="sxs-lookup"><span data-stu-id="00e60-169">First, note the `DataObject` and `DataObjectMethodAttribute` attributes applied to the class and methods.</span></span> <span data-ttu-id="00e60-170">Te atrybuty zawierają informacje do kreatora s ObjectDataSource wskazującą, jakie klasy i metody powinna zostać wyświetlona w krokach s kreatora.</span><span class="sxs-lookup"><span data-stu-id="00e60-170">These attributes provide information to the ObjectDataSource s wizard, indicating what classes and methods should appear in the wizard s steps.</span></span> <span data-ttu-id="00e60-171">Ponieważ CL klasy i metody będą uzyskiwać dostęp z elementu ObjectDataSource w warstwie prezentacji, po dodaniu tych atrybutów w celu poprawienia środowiska czasu projektowania.</span><span class="sxs-lookup"><span data-stu-id="00e60-171">Since the CL classes and methods will be accessed from an ObjectDataSource in the Presentation Layer, I added these attributes to enhance the design-time experience.</span></span> <span data-ttu-id="00e60-172">Odwołaj się do [Tworzenie warstwy logiki biznesowej](../introduction/creating-a-business-logic-layer-vb.md) samouczek bardziej szczegółowego opis tych atrybutów i ich skutki.</span><span class="sxs-lookup"><span data-stu-id="00e60-172">Refer back to the [Creating a Business Logic Layer](../introduction/creating-a-business-logic-layer-vb.md) tutorial for a more thorough description on these attributes and their effects.</span></span>

<span data-ttu-id="00e60-173">W `GetProducts()` i `GetProductsByCategoryID(categoryID)` metody, z danymi zwróconymi z `GetCacheItem(key)` metody jest przypisany do zmiennej lokalnej.</span><span class="sxs-lookup"><span data-stu-id="00e60-173">In the `GetProducts()` and `GetProductsByCategoryID(categoryID)` methods, the data returned from the `GetCacheItem(key)` method is assigned to a local variable.</span></span> <span data-ttu-id="00e60-174">`GetCacheItem(key)` Metody, która zajmiemy się wkrótce, zwraca wartość określonego elementu z pamięci podręcznej na podstawie *klucz*.</span><span class="sxs-lookup"><span data-stu-id="00e60-174">The `GetCacheItem(key)` method, which we'll examine shortly, returns a particular item from the cache based on the specified *key*.</span></span> <span data-ttu-id="00e60-175">Jeśli nie z tych danych znajduje się w pamięci podręcznej, zostanie pobrana z odpowiednich `ProductsBLL` metody klasy, a następnie dodane do pamięci podręcznej, za pomocą `AddCacheItem(key, value)` metody.</span><span class="sxs-lookup"><span data-stu-id="00e60-175">If no such data is found in cache, it is retrieved from the corresponding `ProductsBLL` class method and then added to the cache using the `AddCacheItem(key, value)` method.</span></span>

<span data-ttu-id="00e60-176">`GetCacheItem(key)` i `AddCacheItem(key, value)` metody interfejsu z pamięci podręcznej danych, odczytywanie i zapisywanie wartości odpowiednio.</span><span class="sxs-lookup"><span data-stu-id="00e60-176">The `GetCacheItem(key)` and `AddCacheItem(key, value)` methods interface with the data cache, reading and writing values, respectively.</span></span> <span data-ttu-id="00e60-177">`GetCacheItem(key)` Metoda jest prostsza dwóch.</span><span class="sxs-lookup"><span data-stu-id="00e60-177">The `GetCacheItem(key)` method is the simpler of the two.</span></span> <span data-ttu-id="00e60-178">Po prostu zwraca wartość z klasy pamięci podręcznej przy użyciu przekazanego *klucza*:</span><span class="sxs-lookup"><span data-stu-id="00e60-178">It simply returns the value from the Cache class using the passed-in *key*:</span></span>


[!code-vb[Main](caching-data-in-the-architecture-vb/samples/sample6.vb)]

`GetCacheItem(key)` <span data-ttu-id="00e60-179">nie używa *klucz* wartość dostarczony, ale zamiast tego wywołania `GetCacheKey(key)` metody, która zwraca *klucz* poprzedzonej ciągiem ProductsCache —.</span><span class="sxs-lookup"><span data-stu-id="00e60-179">does not use *key* value as supplied, but instead calls the `GetCacheKey(key)` method, which returns the *key* prepended with ProductsCache-.</span></span> <span data-ttu-id="00e60-180">`MasterCacheKeyArray`, Który zawiera ciąg ProductsCache, jest również używany przez `AddCacheItem(key, value)` metody, ponieważ chwilę zobaczymy.</span><span class="sxs-lookup"><span data-stu-id="00e60-180">The `MasterCacheKeyArray`, which holds the string ProductsCache, is also used by the `AddCacheItem(key, value)` method, as we'll see momentarily.</span></span>

<span data-ttu-id="00e60-181">Z kodem klasę strony ASP.NET pamięci podręcznej danych jest możliwy za pomocą `Page` klasy s [ `Cache` właściwość](https://msdn.microsoft.com/library/system.web.ui.page.cache.aspx)i umożliwia składni `Cache("key") = value`, zgodnie z opisem w kroku 2.</span><span class="sxs-lookup"><span data-stu-id="00e60-181">From an ASP.NET page s code-behind class, the data cache can be accessed using the `Page` class s [`Cache` property](https://msdn.microsoft.com/library/system.web.ui.page.cache.aspx), and allows for syntax like `Cache("key") = value`, as discussed in Step 2.</span></span> <span data-ttu-id="00e60-182">Z klasy w ramach architektury, pamięć podręczną danych jest możliwy za pomocą `HttpRuntime.Cache` lub `HttpContext.Current.Cache`.</span><span class="sxs-lookup"><span data-stu-id="00e60-182">From a class within the architecture, the data cache can be accessed using either `HttpRuntime.Cache` or `HttpContext.Current.Cache`.</span></span> <span data-ttu-id="00e60-183">[Peter Johnson](https://weblogs.asp.net/pjohnson/default.aspx)firmy wpis w blogu [HttpRuntime.Cache programu vs. HttpContext.Current.Cache](https://weblogs.asp.net/pjohnson/httpruntime-cache-vs-httpcontext-current-cache) informacje o niewielkim wzroście wydajności zaletą używania `HttpRuntime` zamiast `HttpContext.Current`; w związku z tym, `ProductsCL` używa `HttpRuntime`.</span><span class="sxs-lookup"><span data-stu-id="00e60-183">[Peter Johnson](https://weblogs.asp.net/pjohnson/default.aspx)'s blog entry [HttpRuntime.Cache vs. HttpContext.Current.Cache](https://weblogs.asp.net/pjohnson/httpruntime-cache-vs-httpcontext-current-cache) notes the slight performance advantage in using `HttpRuntime` instead of `HttpContext.Current`; consequently, `ProductsCL` uses `HttpRuntime`.</span></span>

> [!NOTE]
> <span data-ttu-id="00e60-184">Jeśli architektury jest implementowany przy użyciu biblioteki klas projektów, a następnie należy dodać odwołanie do `System.Web` zestawu, aby można było używać [ `HttpRuntime` ](https://msdn.microsoft.com/library/system.web.httpruntime.aspx) i [ `HttpContext` ](https://msdn.microsoft.com/library/system.web.httpcontext.aspx) klasy.</span><span class="sxs-lookup"><span data-stu-id="00e60-184">If your architecture is implemented using Class Library projects then you will need to add a reference to the `System.Web` assembly in order to use the [`HttpRuntime`](https://msdn.microsoft.com/library/system.web.httpruntime.aspx) and [`HttpContext`](https://msdn.microsoft.com/library/system.web.httpcontext.aspx) classes.</span></span>


<span data-ttu-id="00e60-185">Jeśli element nie zostanie znaleziony w pamięci podręcznej, `ProductsCL` metod klasy s uzyskać danych z LOGIKI i dodaj go do pamięć podręczną za pomocą `AddCacheItem(key, value)` metody.</span><span class="sxs-lookup"><span data-stu-id="00e60-185">If the item is not found in the cache, the `ProductsCL` class s methods get the data from the BLL and add it to the cache using the `AddCacheItem(key, value)` method.</span></span> <span data-ttu-id="00e60-186">Aby dodać *wartość* do pamięci podręcznej moglibyśmy użyć następujący kod, który korzysta z upływem czasu 60 sekundy:</span><span class="sxs-lookup"><span data-stu-id="00e60-186">To add *value* to the cache we could use the following code, which uses a 60 second time expiry:</span></span>


[!code-vb[Main](caching-data-in-the-architecture-vb/samples/sample7.vb)]

`DateTime.Now.AddSeconds(CacheDuration)` <span data-ttu-id="00e60-187">Określa na podstawie czasu wygaśnięcia 60 sekund w przyszłości podczas [ `System.Web.Caching.Cache.NoSlidingExpiration` ](https://msdn.microsoft.com/library/system.web.caching.cache.noslidingexpiration(vs.80).aspx) wskazuje s, ponieważ nie wygaśniecie.</span><span class="sxs-lookup"><span data-stu-id="00e60-187">specifies the time-based expiry 60 seconds in the future while [`System.Web.Caching.Cache.NoSlidingExpiration`](https://msdn.microsoft.com/library/system.web.caching.cache.noslidingexpiration(vs.80).aspx) indicates that there s no sliding expiration.</span></span> <span data-ttu-id="00e60-188">Podczas tego `Insert` przeciążenia metody ma wejściowych parametrów dla obu bezwzględnym i przedłużanie ważności, należy można podać tylko jedną z dwóch.</span><span class="sxs-lookup"><span data-stu-id="00e60-188">While this `Insert` method overload has input parameters for both an absolute and sliding expiry, you can only provide one of the two.</span></span> <span data-ttu-id="00e60-189">Jeśli spróbujesz określić bezwzględnego czasu i przedział czasu `Insert` metoda zgłosi `ArgumentException` wyjątku.</span><span class="sxs-lookup"><span data-stu-id="00e60-189">If you attempt to specify both an absolute time and a time span, the `Insert` method will throw an `ArgumentException` exception.</span></span>

> [!NOTE]
> <span data-ttu-id="00e60-190">Ta implementacja `AddCacheItem(key, value)` metoda obecnie ma pewne wady.</span><span class="sxs-lookup"><span data-stu-id="00e60-190">This implementation of the `AddCacheItem(key, value)` method currently has some shortcomings.</span></span> <span data-ttu-id="00e60-191">Firma Microsoft będzie adresu i rozwiązywania tych problemów w kroku 4.</span><span class="sxs-lookup"><span data-stu-id="00e60-191">We'll address and overcome these issues in Step 4.</span></span>


## <a name="step-4-invalidating-the-cache-when-the-data-is-modified-through-the-architecture"></a><span data-ttu-id="00e60-192">Krok 4. Unieważnienia pamięci podręcznej po danych jest zmodyfikowany za pomocą architektury</span><span class="sxs-lookup"><span data-stu-id="00e60-192">Step 4: Invalidating the Cache When the Data is Modified Through the Architecture</span></span>

<span data-ttu-id="00e60-193">Wraz z metod pobierania danych warstwy buforowania musi podać tej samej metody co LOGIKI Wstawianie, aktualizowanie i usuwanie danych.</span><span class="sxs-lookup"><span data-stu-id="00e60-193">Along with data retrieval methods, the Caching Layer needs to provide the same methods as the BLL for inserting, updating, and deleting data.</span></span> <span data-ttu-id="00e60-194">Metody modyfikacji danych s CL, nie należy modyfikować dane w pamięci podręcznej, ale zamiast wywoływać metodę LOGIKI s do modyfikacji odpowiednich danych, a następnie unieważnienia pamięci podręcznej.</span><span class="sxs-lookup"><span data-stu-id="00e60-194">The CL s data modification methods do not modify the cached data, but rather call the BLL s corresponding data modification method and then invalidate the cache.</span></span> <span data-ttu-id="00e60-195">Jak widzieliśmy w poprzednim samouczku jest takie samo zachowanie, który kontrolki ObjectDataSource ma zastosowanie, gdy jego funkcje pamięci podręcznej są włączone i jego `Insert`, `Update`, lub `Delete` metody są wywoływane.</span><span class="sxs-lookup"><span data-stu-id="00e60-195">As we saw in the preceding tutorial, this is the same behavior that the ObjectDataSource applies when its caching features are enabled and its `Insert`, `Update`, or `Delete` methods are invoked.</span></span>

<span data-ttu-id="00e60-196">Następujące `UpdateProduct` przeciążenia ilustruje sposób implementacji metody modyfikacji danych w CL:</span><span class="sxs-lookup"><span data-stu-id="00e60-196">The following `UpdateProduct` overload illustrates how to implement the data modification methods in the CL:</span></span>


[!code-vb[Main](caching-data-in-the-architecture-vb/samples/sample8.vb)]

<span data-ttu-id="00e60-197">Modyfikowanie danych odpowiedniej warstwy logiki biznesowej, metoda jest wywoływana, ale przed zwróceniem odpowiedzi przez punkt końcowy należy do unieważnienia pamięci podręcznej.</span><span class="sxs-lookup"><span data-stu-id="00e60-197">The appropriate data modification Business Logic Layer method is invoked, but before its response is returned we need to invalidate the cache.</span></span> <span data-ttu-id="00e60-198">Niestety, unieważnienia pamięci podręcznej jest utrudnione ponieważ `ProductsCL` klasy s `GetProducts()` i `GetProductsByCategoryID(categoryID)` metody należy dodać elementy do pamięci podręcznej z różnymi kluczami i `GetProductsByCategoryID(categoryID)` metoda dodaje element pamięci podręcznej różne dla każdego unikatowy *categoryID*.</span><span class="sxs-lookup"><span data-stu-id="00e60-198">Unfortunately, invalidating the cache is not straightforward because the `ProductsCL` class s `GetProducts()` and `GetProductsByCategoryID(categoryID)` methods each add items to the cache with different keys, and the `GetProductsByCategoryID(categoryID)` method adds a different cache item for each unique *categoryID*.</span></span>

<span data-ttu-id="00e60-199">Gdy unieważnienia pamięci podręcznej, należy usunąć *wszystkich* elementów, które mogły zostać dodane przez `ProductsCL` klasy.</span><span class="sxs-lookup"><span data-stu-id="00e60-199">When invalidating the cache, we need to remove *all* of the items that may have been added by the `ProductsCL` class.</span></span> <span data-ttu-id="00e60-200">Można to osiągnąć przez skojarzenie *zależności w pamięci podręcznej* z każdym elementem dodanych do pamięci podręcznej w `AddCacheItem(key, value)` metody.</span><span class="sxs-lookup"><span data-stu-id="00e60-200">This can be accomplished by associating a *cache dependency* with the each item added to the cache in the `AddCacheItem(key, value)` method.</span></span> <span data-ttu-id="00e60-201">Ogólnie rzecz biorąc zależności pamięci podręcznej może być inny element w pamięci podręcznej, plikiem systemu plików, lub dane z bazy danych programu Microsoft SQL Server.</span><span class="sxs-lookup"><span data-stu-id="00e60-201">In general, a cache dependency can be another item in the cache, a file on the file system, or data from a Microsoft SQL Server database.</span></span> <span data-ttu-id="00e60-202">Gdy zależność zmieni się lub jest usuwane z pamięci podręcznej, elementy pamięci podręcznej jest skojarzony z automatycznie obrazuje z pamięci podręcznej.</span><span class="sxs-lookup"><span data-stu-id="00e60-202">When the dependency changes or is removed from the cache, the cache items it is associated with are automatically evicted from the cache.</span></span> <span data-ttu-id="00e60-203">W tym samouczku chcemy utworzyć dodatkowy element w pamięci podręcznej, która służy jako zależność pamięci podręcznej dla wszystkich elementów dodanych do `ProductsCL` klasy.</span><span class="sxs-lookup"><span data-stu-id="00e60-203">For this tutorial, we want to create an additional item in the cache that serves as a cache dependency for all items added through the `ProductsCL` class.</span></span> <span data-ttu-id="00e60-204">Dzięki temu wszystkie te elementy można usunąć z pamięci podręcznej przez usunięcie zależności pamięci podręcznej.</span><span class="sxs-lookup"><span data-stu-id="00e60-204">That way, all of these items can be removed from the cache by simply removing the cache dependency.</span></span>

<span data-ttu-id="00e60-205">Aktualizacja pozwalają s `AddCacheItem(key, value)` forma tak, aby poszczególne elementy dodane do pamięci podręcznej za pomocą tej metody jest skojarzona z zależności jednej pamięci podręcznej:</span><span class="sxs-lookup"><span data-stu-id="00e60-205">Let s update the `AddCacheItem(key, value)` method so that each item added to the cache through this method is associated with a single cache dependency:</span></span>


[!code-vb[Main](caching-data-in-the-architecture-vb/samples/sample9.vb)]

`MasterCacheKeyArray` <span data-ttu-id="00e60-206">jest tablicą ciągów, który zawiera pojedynczą wartość ProductsCache.</span><span class="sxs-lookup"><span data-stu-id="00e60-206">is a string array that holds a single value, ProductsCache.</span></span> <span data-ttu-id="00e60-207">Po pierwsze element pamięci podręcznej zostaną dodane do pamięci podręcznej i przypisane do bieżącej daty i godziny.</span><span class="sxs-lookup"><span data-stu-id="00e60-207">First, a cache item is added to the cache and assigned the current date and time.</span></span> <span data-ttu-id="00e60-208">Jeśli istnieje już element pamięci podręcznej, jest aktualizowana.</span><span class="sxs-lookup"><span data-stu-id="00e60-208">If the cache item already exists, it is updated.</span></span> <span data-ttu-id="00e60-209">Następnie jest tworzony zależności pamięci podręcznej.</span><span class="sxs-lookup"><span data-stu-id="00e60-209">Next, a cache dependency is created.</span></span> <span data-ttu-id="00e60-210">[ `CacheDependency` Klasy](https://msdn.microsoft.com/library/system.web.caching.cachedependency(VS.80).aspx) s Konstruktor ma wiele przeciążeń, ale użytego w tym miejscu oczekuje, że dwa `String` tablicy danych wejściowych.</span><span class="sxs-lookup"><span data-stu-id="00e60-210">The [`CacheDependency` class](https://msdn.microsoft.com/library/system.web.caching.cachedependency(VS.80).aspx) s constructor has a number of overloads, but the one being used in here expects two `String` array inputs.</span></span> <span data-ttu-id="00e60-211">Pierwsza z nich określa zestaw plików, które ma być używany jako zależności.</span><span class="sxs-lookup"><span data-stu-id="00e60-211">The first one specifies the set of files to be used as dependencies.</span></span> <span data-ttu-id="00e60-212">Ponieważ firma Microsoft don t ma być używana wszelkie zależności opartych na plikach, wartość `Nothing` jest używany jako pierwszy parametr wejściowy.</span><span class="sxs-lookup"><span data-stu-id="00e60-212">Since we don t want to use any file-based dependencies, a value of `Nothing` is used for the first input parameter.</span></span> <span data-ttu-id="00e60-213">Drugi parametr wejściowy określa zestaw kluczy pamięci podręcznej do użycia jako zależności.</span><span class="sxs-lookup"><span data-stu-id="00e60-213">The second input parameter specifies the set of cache keys to use as dependencies.</span></span> <span data-ttu-id="00e60-214">W tym miejscu możemy określić zależność pojedynczego `MasterCacheKeyArray`.</span><span class="sxs-lookup"><span data-stu-id="00e60-214">Here we specify our single dependency, `MasterCacheKeyArray`.</span></span> <span data-ttu-id="00e60-215">`CacheDependency` Jest następnie przekazywany do `Insert` metody.</span><span class="sxs-lookup"><span data-stu-id="00e60-215">The `CacheDependency` is then passed into the `Insert` method.</span></span>

<span data-ttu-id="00e60-216">Za pomocą tej modyfikacji `AddCacheItem(key, value)`, invaliding pamięć podręczna jest proste i polega na usunięciu zależności.</span><span class="sxs-lookup"><span data-stu-id="00e60-216">With this modification to `AddCacheItem(key, value)`, invaliding the cache is as simple as removing the dependency.</span></span>


[!code-vb[Main](caching-data-in-the-architecture-vb/samples/sample10.vb)]

## <a name="step-5-calling-the-caching-layer-from-the-presentation-layer"></a><span data-ttu-id="00e60-217">Krok 5. Wywoływanie warstwy pamięci podręcznej z warstwy prezentacji</span><span class="sxs-lookup"><span data-stu-id="00e60-217">Step 5: Calling the Caching Layer from the Presentation Layer</span></span>

<span data-ttu-id="00e60-218">Pamięć podręczna warstwy s klas i metod może służyć do pracy z danymi za pomocą technik możemy ve badany w całym tych samouczków.</span><span class="sxs-lookup"><span data-stu-id="00e60-218">The Caching Layer s classes and methods can be used to work with data using the techniques we ve examined throughout these tutorials.</span></span> <span data-ttu-id="00e60-219">Aby zilustrować pracy przy użyciu danych z pamięci podręcznej, zapisać zmiany w `ProductsCL` klasy, a następnie otwórz `FromTheArchitecture.aspx` strony w `Caching` folderze i Dodaj GridView.</span><span class="sxs-lookup"><span data-stu-id="00e60-219">To illustrate working with cached data, save your changes to the `ProductsCL` class and then open the `FromTheArchitecture.aspx` page in the `Caching` folder and add a GridView.</span></span> <span data-ttu-id="00e60-220">W tagu inteligentnego s GridView należy utworzyć nowe kontrolki ObjectDataSource.</span><span class="sxs-lookup"><span data-stu-id="00e60-220">From the GridView s smart tag, create a new ObjectDataSource.</span></span> <span data-ttu-id="00e60-221">W pierwszym kroku s kreator powinien zostać wyświetlony `ProductsCL` klasy jako jedną z opcji z listy rozwijanej.</span><span class="sxs-lookup"><span data-stu-id="00e60-221">In the wizard s first step you should see the `ProductsCL` class as one of the options from the drop-down list.</span></span>


[![T<span data-ttu-id="00e60-222">ADAM klasy ProductsCL znajduje się na liście rozwijanej obiektów biznesowych]</span><span class="sxs-lookup"><span data-stu-id="00e60-222">he ProductsCL Class is Included in the Business Object Drop-Down List]</span></span>(caching-data-in-the-architecture-vb/_static/image5.png)](caching-data-in-the-architecture-vb/_static/image4.png)

<span data-ttu-id="00e60-223">**Rysunek 4**: `ProductsCL` Klasa znajduje się na liście rozwijanej obiektów Business ([kliknij, aby wyświetlić obraz w pełnym rozmiarze](caching-data-in-the-architecture-vb/_static/image6.png))</span><span class="sxs-lookup"><span data-stu-id="00e60-223">**Figure 4**: The `ProductsCL` Class is Included in the Business Object Drop-Down List ([Click to view full-size image](caching-data-in-the-architecture-vb/_static/image6.png))</span></span>


<span data-ttu-id="00e60-224">Po wybraniu `ProductsCL`, kliknij przycisk Dalej.</span><span class="sxs-lookup"><span data-stu-id="00e60-224">After selecting `ProductsCL`, click Next.</span></span> <span data-ttu-id="00e60-225">Listy rozwijanej wybierz karta ma dwa elementy — `GetProducts()` i `GetProductsByCategoryID(categoryID)` i na karcie aktualizacji ma jedyny `UpdateProduct` przeciążenia.</span><span class="sxs-lookup"><span data-stu-id="00e60-225">The drop-down list in the SELECT tab has two items - `GetProducts()` and `GetProductsByCategoryID(categoryID)` and the UPDATE tab has the sole `UpdateProduct` overload.</span></span> <span data-ttu-id="00e60-226">Wybierz `GetProducts()` metody z wybierz kartę i `UpdateProducts` metody z karty aktualizacji i kliknij przycisk Zakończ.</span><span class="sxs-lookup"><span data-stu-id="00e60-226">Choose the `GetProducts()` method from the SELECT tab and the `UpdateProducts` method from the UPDATE tab and click Finish.</span></span>


[![T<span data-ttu-id="00e60-227">ADAM, które metody s ProductsCL klasy są wymienione w listy rozwijanej]</span><span class="sxs-lookup"><span data-stu-id="00e60-227">he ProductsCL Class s Methods are Listed in the Drop-Down Lists]</span></span>(caching-data-in-the-architecture-vb/_static/image8.png)](caching-data-in-the-architecture-vb/_static/image7.png)

<span data-ttu-id="00e60-228">**Rysunek 5**: `ProductsCL` Metod klasy s są wymienione w listy rozwijanej ([kliknij, aby wyświetlić obraz w pełnym rozmiarze](caching-data-in-the-architecture-vb/_static/image9.png))</span><span class="sxs-lookup"><span data-stu-id="00e60-228">**Figure 5**: The `ProductsCL` Class s Methods are Listed in the Drop-Down Lists ([Click to view full-size image](caching-data-in-the-architecture-vb/_static/image9.png))</span></span>


<span data-ttu-id="00e60-229">Po ukończeniu kreatora, program Visual Studio ustawi ObjectDataSource s `OldValuesParameterFormatString` właściwość `original_{0}` i dodaj odpowiednie pola do widoku GridView.</span><span class="sxs-lookup"><span data-stu-id="00e60-229">After completing the wizard, Visual Studio will set the ObjectDataSource s `OldValuesParameterFormatString` property to `original_{0}` and add the appropriate fields to the GridView.</span></span> <span data-ttu-id="00e60-230">Zmiana `OldValuesParameterFormatString` jego wartość domyślną właściwości `{0}`i skonfiguruj GridView do obsługi stronicowania, sortowania i edytowania.</span><span class="sxs-lookup"><span data-stu-id="00e60-230">Change the `OldValuesParameterFormatString` property back to its default value, `{0}`, and configure the GridView to support paging, sorting, and editing.</span></span> <span data-ttu-id="00e60-231">Ponieważ `UploadProducts` przeciążenia, które posługują się CL akceptuje tylko nazwę edytowanego produktu s i ceny, ograniczyć widoku GridView, tak aby tylko te pola są edytowalne.</span><span class="sxs-lookup"><span data-stu-id="00e60-231">Since the `UploadProducts` overload used by the CL accepts only the edited product s name and price, limit the GridView so that only these fields are editable.</span></span>

<span data-ttu-id="00e60-232">W poprzednim samouczku zdefiniowaliśmy GridView podczas dołączania pól dla `ProductName`, `CategoryName`, i `UnitPrice` pola.</span><span class="sxs-lookup"><span data-stu-id="00e60-232">In the preceding tutorial we defined a GridView to include fields for the `ProductName`, `CategoryName`, and `UnitPrice` fields.</span></span> <span data-ttu-id="00e60-233">Możesz replikować ten formatowania i struktury, w którym to przypadku Twoje s kontrolkami GridView i kontrolki ObjectDataSource deklaratywne znaczników powinien wyglądać podobnie do następującego:</span><span class="sxs-lookup"><span data-stu-id="00e60-233">Feel free to replicate this formatting and structure, in which case your GridView and ObjectDataSource s declarative markup should look similar to the following:</span></span>


[!code-aspx[Main](caching-data-in-the-architecture-vb/samples/sample11.aspx)]

<span data-ttu-id="00e60-234">W tym momencie mamy strona, która korzysta z warstwy pamięci podręcznej.</span><span class="sxs-lookup"><span data-stu-id="00e60-234">At this point we have a page that uses the Caching Layer.</span></span> <span data-ttu-id="00e60-235">Aby wyświetlić pamięci podręcznej w działaniu, ustawić punkty przerwania `ProductsCL` klasy s `GetProducts()` i `UpdateProduct` metody.</span><span class="sxs-lookup"><span data-stu-id="00e60-235">To see the cache in action, set breakpoints in the `ProductsCL` class s `GetProducts()` and `UpdateProduct` methods.</span></span> <span data-ttu-id="00e60-236">Odwiedź stronę w przeglądarce i Przechodź przez kod, podczas sortowania i stronicowania, aby można było wyświetlać dane pobrane z pamięci podręcznej.</span><span class="sxs-lookup"><span data-stu-id="00e60-236">Visit the page in a browser and step through the code when sorting and paging in order to see the data pulled from the cache.</span></span> <span data-ttu-id="00e60-237">Następnie zaktualizuj rekord i Zauważ, że pamięć podręczna zostaje unieważniony, i w związku z tym, jest pobierana z LOGIKI po danych jest odbitych do kontrolki GridView.</span><span class="sxs-lookup"><span data-stu-id="00e60-237">Then update a record and note that the cache is invalidated and, consequently, it is retrieved from the BLL when the data is rebound to the GridView.</span></span>

> [!NOTE]
> <span data-ttu-id="00e60-238">Warstwy buforowania, udostępniane do pobrania, towarzyszący w tym artykule nie została ukończona.</span><span class="sxs-lookup"><span data-stu-id="00e60-238">The Caching Layer provided in the download accompanying this article is not complete.</span></span> <span data-ttu-id="00e60-239">Zawiera ona tylko jedną klasę `ProductsCL`, który sportowe tylko niewielki podzbiór metod.</span><span class="sxs-lookup"><span data-stu-id="00e60-239">It contains only one class, `ProductsCL`, which only sports a handful of methods.</span></span> <span data-ttu-id="00e60-240">Ponadto tylko jednej strony ASP.NET używa CL (`~/Caching/FromTheArchitecture.aspx`) wszystkie pozostałe nadal odwoływać się do LOGIKI bezpośrednio.</span><span class="sxs-lookup"><span data-stu-id="00e60-240">Moreover, only a single ASP.NET page uses the CL (`~/Caching/FromTheArchitecture.aspx`) all others still reference the BLL directly.</span></span> <span data-ttu-id="00e60-241">Jeśli planujesz używanie CL w aplikacji, wszystkie wywołania z warstwy prezentacji przejdź do CL, co wymagałoby, klasy s CL i metody omówione tych klas i metod w LOGIKI obecnie używana przez warstwę prezentacji.</span><span class="sxs-lookup"><span data-stu-id="00e60-241">If you plan on using a CL in your application, all calls from the Presentation Layer should go to the CL, which would require that the CL s classes and methods covered those classes and methods in the BLL currently used by the Presentation Layer.</span></span>


## <a name="summary"></a><span data-ttu-id="00e60-242">Podsumowanie</span><span class="sxs-lookup"><span data-stu-id="00e60-242">Summary</span></span>

<span data-ttu-id="00e60-243">Podczas buforowania można zastosować na warstwę prezentacji z ASP.NET 2.0 s SqlDataSource i kontrolki ObjectDataSource, najlepiej buforowania obowiązki będzie delegowane do oddzielnych warstwy w architekturze.</span><span class="sxs-lookup"><span data-stu-id="00e60-243">While caching can be applied at the Presentation Layer with ASP.NET 2.0 s SqlDataSource and ObjectDataSource controls, ideally caching responsibilities would be delegated to a separate layer in the architecture.</span></span> <span data-ttu-id="00e60-244">W tym samouczku utworzyliśmy warstwy buforowania, który znajduje się między warstwą prezentacji i warstwy logiki biznesowej.</span><span class="sxs-lookup"><span data-stu-id="00e60-244">In this tutorial we created a Caching Layer that resides between the Presentation Layer and the Business Logic Layer.</span></span> <span data-ttu-id="00e60-245">Warstwy buforowania musi udostępniają identyczny zestaw klas i metod, które istnieją w LOGIKI i są wywoływane z warstwy prezentacji.</span><span class="sxs-lookup"><span data-stu-id="00e60-245">The Caching Layer needs to provide the same set of classes and methods that exist in the BLL and are called from the Presentation Layer.</span></span>

<span data-ttu-id="00e60-246">Przykłady warstwy buforowania, rozważyliśmy w tym i w poprzednich samouczkach uwidocznione *reaktywne ładowania*.</span><span class="sxs-lookup"><span data-stu-id="00e60-246">The Caching Layer examples we explored in this and the preceding tutorials exhibited *reactive loading*.</span></span> <span data-ttu-id="00e60-247">Przy użyciu ładowania reaktywne dane są ładowane do pamięci podręcznej, tylko po wysłaniu żądania danych i Brak danych z pamięci podręcznej.</span><span class="sxs-lookup"><span data-stu-id="00e60-247">With reactive loading, the data is loaded into the cache only when a request for the data is made and that data is missing from the cache.</span></span> <span data-ttu-id="00e60-248">Dane mogą być również *aktywnie załadować* w pamięci podręcznej, to technika, służy do ładowania danych w pamięci podręcznej, zanim będzie to wymagane.</span><span class="sxs-lookup"><span data-stu-id="00e60-248">Data can also be *proactively loaded* into the cache, a technique that loads the data into the cache before it is actually needed.</span></span> <span data-ttu-id="00e60-249">W następnym samouczku zobaczymy przykładem aktywne ładowanie, gdy spojrzymy na sposób przechowywania wartości statycznej w pamięci podręcznej podczas uruchamiania aplikacji.</span><span class="sxs-lookup"><span data-stu-id="00e60-249">In the next tutorial we'll see an example of proactive loading when we look at how to store static values into the cache at application startup.</span></span>

<span data-ttu-id="00e60-250">Wszystkiego najlepszego programowania!</span><span class="sxs-lookup"><span data-stu-id="00e60-250">Happy Programming!</span></span>

## <a name="about-the-author"></a><span data-ttu-id="00e60-251">Informacje o autorze</span><span class="sxs-lookup"><span data-stu-id="00e60-251">About the Author</span></span>

<span data-ttu-id="00e60-252">[Scott Bento](http://www.4guysfromrolla.com/ScottMitchell.shtml), autor siedem ASP/ASP.NET książek i założycielem [4GuysFromRolla.com](http://www.4guysfromrolla.com), pracował nad przy użyciu technologii Microsoft Web od 1998 r.</span><span class="sxs-lookup"><span data-stu-id="00e60-252">[Scott Mitchell](http://www.4guysfromrolla.com/ScottMitchell.shtml), author of seven ASP/ASP.NET books and founder of [4GuysFromRolla.com](http://www.4guysfromrolla.com), has been working with Microsoft Web technologies since 1998.</span></span> <span data-ttu-id="00e60-253">Scott działa jako niezależny Konsultant, trainer i składnika zapisywania.</span><span class="sxs-lookup"><span data-stu-id="00e60-253">Scott works as an independent consultant, trainer, and writer.</span></span> <span data-ttu-id="00e60-254">Jego najnowszą książkę Stephena [ *Sams uczyć się ASP.NET 2.0 w ciągu 24 godzin*](https://www.amazon.com/exec/obidos/ASIN/0672327384/4guysfromrollaco).</span><span class="sxs-lookup"><span data-stu-id="00e60-254">His latest book is [*Sams Teach Yourself ASP.NET 2.0 in 24 Hours*](https://www.amazon.com/exec/obidos/ASIN/0672327384/4guysfromrollaco).</span></span> <span data-ttu-id="00e60-255">ADAM można z Tobą skontaktować w [ mitchell@4GuysFromRolla.com.](mailto:mitchell@4GuysFromRolla.com)</span><span class="sxs-lookup"><span data-stu-id="00e60-255">He can be reached at [mitchell@4GuysFromRolla.com.](mailto:mitchell@4GuysFromRolla.com)</span></span> <span data-ttu-id="00e60-256">lub za pośrednictwem jego blogu, który znajduje się w temacie [ http://ScottOnWriting.NET ](http://ScottOnWriting.NET).</span><span class="sxs-lookup"><span data-stu-id="00e60-256">or via his blog, which can be found at [http://ScottOnWriting.NET](http://ScottOnWriting.NET).</span></span>

## <a name="special-thanks-to"></a><span data-ttu-id="00e60-257">Specjalne podziękowania dla</span><span class="sxs-lookup"><span data-stu-id="00e60-257">Special Thanks To</span></span>

<span data-ttu-id="00e60-258">W tej serii samouczków został zrecenzowany przez wielu recenzentów pomocne.</span><span class="sxs-lookup"><span data-stu-id="00e60-258">This tutorial series was reviewed by many helpful reviewers.</span></span> <span data-ttu-id="00e60-259">Weryfikacja potencjalnych klientów w ramach tego samouczka został Teresa Murphy.</span><span class="sxs-lookup"><span data-stu-id="00e60-259">Lead reviewer for this tutorial was Teresa Murphy.</span></span> <span data-ttu-id="00e60-260">Zainteresowani zapoznaniem Moje kolejnych artykułów MSDN?</span><span class="sxs-lookup"><span data-stu-id="00e60-260">Interested in reviewing my upcoming MSDN articles?</span></span> <span data-ttu-id="00e60-261">Jeśli tak, Porzuć mnie linii w [ mitchell@4GuysFromRolla.com.](mailto:mitchell@4GuysFromRolla.com)</span><span class="sxs-lookup"><span data-stu-id="00e60-261">If so, drop me a line at [mitchell@4GuysFromRolla.com.](mailto:mitchell@4GuysFromRolla.com)</span></span>

> [!div class="step-by-step"]
> <span data-ttu-id="00e60-262">[Poprzednie](caching-data-with-the-objectdatasource-vb.md)
> [dalej](caching-data-at-application-startup-vb.md)</span><span class="sxs-lookup"><span data-stu-id="00e60-262">[Previous](caching-data-with-the-objectdatasource-vb.md)
[Next](caching-data-at-application-startup-vb.md)</span></span>
