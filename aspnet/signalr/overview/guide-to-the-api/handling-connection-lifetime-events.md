---
uid: signalr/overview/guide-to-the-api/handling-connection-lifetime-events
title: Opis i obsługa zdarzeń okresu istnienia połączenia w SignalR | Dokumentacja firmy Microsoft
author: bradygaster
description: W tym artykule opisano korzystanie ze zdarzeń udostępnianych przez interfejs API koncentratorów.
ms.author: bradyg
ms.date: 01/15/2019
ms.assetid: 03960de2-8d95-4444-9169-4426dcc64913
msc.legacyurl: /signalr/overview/guide-to-the-api/handling-connection-lifetime-events
msc.type: authoredcontent
ms.openlocfilehash: 9e6b0b3b86839efa393659531d8b74770226f383
ms.sourcegitcommit: 0f1119340e4464720cfd16d0ff15764746ea1fea
ms.translationtype: MT
ms.contentlocale: pl-PL
ms.lasthandoff: 04/09/2019
ms.locfileid: "59401468"
---
# <a name="understanding-and-handling-connection-lifetime-events-in-signalr"></a><span data-ttu-id="93fc6-103">Objaśnienie i obsługa zdarzeń okresu istnienia połączenia w usłudze SignalR</span><span class="sxs-lookup"><span data-stu-id="93fc6-103">Understanding and Handling Connection Lifetime Events in SignalR</span></span>


[!INCLUDE [Consider ASP.NET Core SignalR](~/includes/signalr/signalr-version-disambiguation.md)]

> <span data-ttu-id="93fc6-104">Ten artykuł zawiera omówienie SignalR połączenie, ponowne nawiązanie połączenia i rozłączenia zdarzenia, które może obsłużyć i ustawienia limitu czasu i utrzymywania aktywności, które można skonfigurować.</span><span class="sxs-lookup"><span data-stu-id="93fc6-104">This article provides an overview of the SignalR connection, reconnection, and disconnection events that you can handle, and timeout and keepalive settings that you can configure.</span></span>
>
> <span data-ttu-id="93fc6-105">Tego artykułu przyjęto założenie, że masz już pewną wiedzę na temat zdarzenia okresu istnienia połączenia i SignalR.</span><span class="sxs-lookup"><span data-stu-id="93fc6-105">The article assumes you already have some knowledge of SignalR and connection lifetime events.</span></span> <span data-ttu-id="93fc6-106">Wprowadzenie do SignalR, patrz [wprowadzenie do SignalR](../getting-started/introduction-to-signalr.md).</span><span class="sxs-lookup"><span data-stu-id="93fc6-106">For an introduction to SignalR, see [Introduction to SignalR](../getting-started/introduction-to-signalr.md).</span></span> <span data-ttu-id="93fc6-107">Wyświetla zdarzenia okresu istnienia połączenia na ten temat można znaleźć w następujących zasobach:</span><span class="sxs-lookup"><span data-stu-id="93fc6-107">For lists of connection lifetime events, see the following resources:</span></span>
>
> - [<span data-ttu-id="93fc6-108">Jak obsługiwać zdarzenia okresu istnienia połączenia w klasie Centrum</span><span class="sxs-lookup"><span data-stu-id="93fc6-108">How to handle connection lifetime events in the Hub class</span></span>](hubs-api-guide-server.md#connectionlifetime)
> - [<span data-ttu-id="93fc6-109">Jak obsługiwać zdarzenia okresu istnienia połączenia w klientów języka JavaScript</span><span class="sxs-lookup"><span data-stu-id="93fc6-109">How to handle connection lifetime events in JavaScript clients</span></span>](hubs-api-guide-javascript-client.md#connectionlifetime)
> - [<span data-ttu-id="93fc6-110">Jak obsługiwać zdarzenia okresu istnienia połączenia w przypadku klientów programu .NET</span><span class="sxs-lookup"><span data-stu-id="93fc6-110">How to handle connection lifetime events in .NET clients</span></span>](hubs-api-guide-net-client.md#connectionlifetime)
>
> ## <a name="software-versions-used-in-this-topic"></a><span data-ttu-id="93fc6-111">Wersje oprogramowania używaną w tym temacie</span><span class="sxs-lookup"><span data-stu-id="93fc6-111">Software versions used in this topic</span></span>
>
>
> - [<span data-ttu-id="93fc6-112">Visual Studio 2017</span><span class="sxs-lookup"><span data-stu-id="93fc6-112">Visual Studio 2017</span></span>](https://visualstudio.microsoft.com/downloads/)
> - <span data-ttu-id="93fc6-113">.NET 4.5</span><span class="sxs-lookup"><span data-stu-id="93fc6-113">.NET 4.5</span></span>
> - <span data-ttu-id="93fc6-114">SignalR w wersji 2</span><span class="sxs-lookup"><span data-stu-id="93fc6-114">SignalR version 2</span></span>
>
>
>
> ## <a name="previous-versions-of-this-topic"></a><span data-ttu-id="93fc6-115">Poprzednie wersje tego tematu</span><span class="sxs-lookup"><span data-stu-id="93fc6-115">Previous versions of this topic</span></span>
>
> <span data-ttu-id="93fc6-116">Aby uzyskać informacje dotyczące starszych wersji biblioteki SignalR, zobacz [starsze wersje biblioteki SignalR](../older-versions/index.md).</span><span class="sxs-lookup"><span data-stu-id="93fc6-116">For information about earlier versions of SignalR, see [SignalR Older Versions](../older-versions/index.md).</span></span>
>
> ## <a name="questions-and-comments"></a><span data-ttu-id="93fc6-117">Pytania i komentarze</span><span class="sxs-lookup"><span data-stu-id="93fc6-117">Questions and comments</span></span>
>
> <span data-ttu-id="93fc6-118">Jak się podoba w tym samouczku, i co można było ulepszyć proces w komentarzach u dołu strony, wystaw opinię.</span><span class="sxs-lookup"><span data-stu-id="93fc6-118">Please leave feedback on how you liked this tutorial and what we could improve in the comments at the bottom of the page.</span></span> <span data-ttu-id="93fc6-119">Jeśli masz pytania, na które nie są bezpośrednio związane z tego samouczka, możesz zamieścić je do [forum ASP.NET SignalR](https://forums.asp.net/1254.aspx/1?ASP+NET+SignalR) lub [StackOverflow.com](http://stackoverflow.com/).</span><span class="sxs-lookup"><span data-stu-id="93fc6-119">If you have questions that are not directly related to the tutorial, you can post them to the [ASP.NET SignalR forum](https://forums.asp.net/1254.aspx/1?ASP+NET+SignalR) or [StackOverflow.com](http://stackoverflow.com/).</span></span>

## <a name="overview"></a><span data-ttu-id="93fc6-120">Omówienie</span><span class="sxs-lookup"><span data-stu-id="93fc6-120">Overview</span></span>

<span data-ttu-id="93fc6-121">Ten artykuł zawiera następujące sekcje:</span><span class="sxs-lookup"><span data-stu-id="93fc6-121">This article contains the following sections:</span></span>

- [<span data-ttu-id="93fc6-122">Terminologia okres istnienia połączenia i scenariusze</span><span class="sxs-lookup"><span data-stu-id="93fc6-122">Connection lifetime terminology and scenarios</span></span>](#terminology)

    - [<span data-ttu-id="93fc6-123">Połączenia SignalR, połączenia transportu i fizycznych połączeń</span><span class="sxs-lookup"><span data-stu-id="93fc6-123">SignalR connections, transport connections, and physical connections</span></span>](#signalrvstransport)
    - [<span data-ttu-id="93fc6-124">Scenariusze rozłączenia transportu</span><span class="sxs-lookup"><span data-stu-id="93fc6-124">Transport disconnection scenarios</span></span>](#transportdisconnect)
    - [<span data-ttu-id="93fc6-125">Scenariusze rozłączenia klienta</span><span class="sxs-lookup"><span data-stu-id="93fc6-125">Client disconnection scenarios</span></span>](#clientdisconnect)
    - [<span data-ttu-id="93fc6-126">Scenariusze odłączenia serwera</span><span class="sxs-lookup"><span data-stu-id="93fc6-126">Server disconnection scenarios</span></span>](#serverdisconnect)
- [<span data-ttu-id="93fc6-127">Ustawienia limitu czasu i utrzymywania aktywności</span><span class="sxs-lookup"><span data-stu-id="93fc6-127">Timeout and keepalive settings</span></span>](#timeoutkeepalive)

    - [<span data-ttu-id="93fc6-128">ConnectionTimeout</span><span class="sxs-lookup"><span data-stu-id="93fc6-128">ConnectionTimeout</span></span>](#connectiontimeout)
    - [<span data-ttu-id="93fc6-129">DisconnectTimeout</span><span class="sxs-lookup"><span data-stu-id="93fc6-129">DisconnectTimeout</span></span>](#disconnecttimeout)
    - [<span data-ttu-id="93fc6-130">KeepAlive</span><span class="sxs-lookup"><span data-stu-id="93fc6-130">KeepAlive</span></span>](#keepalive)
    - [<span data-ttu-id="93fc6-131">Jak zmienić ustawienia limitu czasu i utrzymywania aktywności</span><span class="sxs-lookup"><span data-stu-id="93fc6-131">How to change timeout and keepalive settings</span></span>](#changetimeout)
- [<span data-ttu-id="93fc6-132">Jak powiadamiać użytkownika o odłączenia</span><span class="sxs-lookup"><span data-stu-id="93fc6-132">How to notify the user about disconnections</span></span>](#notifydisconnect)
- [<span data-ttu-id="93fc6-133">Jak ponownie w sposób ciągły</span><span class="sxs-lookup"><span data-stu-id="93fc6-133">How to continuously reconnect</span></span>](#continuousreconnect)
- [<span data-ttu-id="93fc6-134">Jak odłączyć klienta w kodzie serwera</span><span class="sxs-lookup"><span data-stu-id="93fc6-134">How to disconnect a client in server code</span></span>](#disconnectclientfromserver)
- [<span data-ttu-id="93fc6-135">Wykrywanie Przyczyna zakończenia połączenia</span><span class="sxs-lookup"><span data-stu-id="93fc6-135">Detecting the reason for a disconnection</span></span>](#detectingreasonfordisconnection)

<span data-ttu-id="93fc6-136">Łącza do tematów, dokumentacja interfejsu API są .NET 4.5 wersję interfejsu API.</span><span class="sxs-lookup"><span data-stu-id="93fc6-136">Links to API Reference topics are to the .NET 4.5 version of the API.</span></span> <span data-ttu-id="93fc6-137">Jeśli używasz programu .NET 4, zobacz [tematy interfejsu API w wersji .NET 4](https://msdn.microsoft.com/library/jj891075(v=vs.100).aspx).</span><span class="sxs-lookup"><span data-stu-id="93fc6-137">If you're using .NET 4, see [the .NET 4 version of the API topics](https://msdn.microsoft.com/library/jj891075(v=vs.100).aspx).</span></span>

<a id="terminology"></a>

## <a name="connection-lifetime-terminology-and-scenarios"></a><span data-ttu-id="93fc6-138">Terminologia okres istnienia połączenia i scenariusze</span><span class="sxs-lookup"><span data-stu-id="93fc6-138">Connection lifetime terminology and scenarios</span></span>

<span data-ttu-id="93fc6-139">`OnReconnected` Programu obsługi zdarzeń w Centrum SignalR można wykonać bezpośrednio po `OnConnected` , ale nie po `OnDisconnected` dla danego klienta.</span><span class="sxs-lookup"><span data-stu-id="93fc6-139">The `OnReconnected` event handler in a SignalR Hub can execute directly after `OnConnected` but not after `OnDisconnected` for a given client.</span></span> <span data-ttu-id="93fc6-140">Przyczyna może mieć ponowne połączenie bez rozłączeniu zakłada, że kilka sposobów, w których wyraz "connection" jest używany w SignalR.</span><span class="sxs-lookup"><span data-stu-id="93fc6-140">The reason you can have a reconnection without a disconnection is that there are several ways in which the word "connection" is used in SignalR.</span></span>

<a id="signalrvstransport"></a>

### <a name="signalr-connections-transport-connections-and-physical-connections"></a><span data-ttu-id="93fc6-141">Połączenia SignalR, połączenia transportu i fizycznych połączeń</span><span class="sxs-lookup"><span data-stu-id="93fc6-141">SignalR connections, transport connections, and physical connections</span></span>

<span data-ttu-id="93fc6-142">Ten artykuł będzie odróżnić *połączeniami SignalR*, *transportu połączenia*, i *połączeń fizycznych*:</span><span class="sxs-lookup"><span data-stu-id="93fc6-142">This article will differentiate between *SignalR connections*, *transport connections*, and *physical connections*:</span></span>

- <span data-ttu-id="93fc6-143">**Połączenia SignalR** odwołuje się do relacji logicznych między klientem i adres URL serwera, obsługiwany przez interfejs API SignalR, unikatowo identyfikowana przez identyfikator połączenia.</span><span class="sxs-lookup"><span data-stu-id="93fc6-143">**SignalR connection** refers to a logical relationship between a client and a server URL, maintained by the SignalR API and uniquely identified by a connection ID.</span></span> <span data-ttu-id="93fc6-144">Dane dotyczące tej relacji jest obsługiwany przez SignalR, jest używany do ustanawiania połączenia transportu.</span><span class="sxs-lookup"><span data-stu-id="93fc6-144">The data about this relationship is maintained by SignalR and is used to establish a transport connection.</span></span> <span data-ttu-id="93fc6-145">Końce relacji i SignalR usuwa danych, gdy klient wywołuje `Stop` metody lub limit czasu zostanie osiągnięty podczas SignalR próby ponownego nawiązania połączenia transportu utracone.</span><span class="sxs-lookup"><span data-stu-id="93fc6-145">The relationship ends and SignalR disposes of the data when the client calls the `Stop` method or a timeout limit is reached while SignalR is attempting to re-establish a lost transport connection.</span></span>
- <span data-ttu-id="93fc6-146">**Połączenie będzie transportowane** odwołuje się do relacji logicznych między klientem a serwerem, obsługiwane przez jedną z czterech transportu interfejsów API: Gniazda Websocket, zdarzenia wysłanego przez serwer, nieskończoność ramki lub długiego sondowania.</span><span class="sxs-lookup"><span data-stu-id="93fc6-146">**Transport connection** refers to a logical relationship between a client and a server, maintained by one of the four transport APIs: WebSockets, server-sent events, forever frame, or long polling.</span></span> <span data-ttu-id="93fc6-147">SignalR używa transportu interfejsu API można utworzyć połączenia transportowego i interfejsów API transportu zależy od istnienia połączenia sieci fizycznej, można utworzyć połączenia transportowego.</span><span class="sxs-lookup"><span data-stu-id="93fc6-147">SignalR uses the transport API to create a transport connection, and the transport API depends on the existence of a physical network connection to create the transport connection.</span></span> <span data-ttu-id="93fc6-148">Połączenie transportu kończy się, gdy SignalR kończy go lub transportu API wykryje, że fizyczne połączenie jest uszkodzone.</span><span class="sxs-lookup"><span data-stu-id="93fc6-148">The transport connection ends when SignalR terminates it or when the transport API detects that the physical connection is broken.</span></span>
- <span data-ttu-id="93fc6-149">**Fizyczne połączenie** odwołuje się do łącza sieci fizycznej — przewodów, sygnały sieci bezprzewodowej, routery, itp. — ułatwiają komunikację między komputerem klienckim a serwerem.</span><span class="sxs-lookup"><span data-stu-id="93fc6-149">**Physical connection** refers to the physical network links -- wires, wireless signals, routers, etc. -- that facilitate communication between a client computer and a server computer.</span></span> <span data-ttu-id="93fc6-150">Fizyczne połączenie musi być obecna, aby możliwe było nawiązanie połączenia transportu i można ustanowić połączenia transportu w celu ustanowienia połączenia SignalR.</span><span class="sxs-lookup"><span data-stu-id="93fc6-150">The physical connection must be present in order to establish a transport connection, and a transport connection must be established in order to establish a SignalR connection.</span></span> <span data-ttu-id="93fc6-151">Jednak istotne fizycznego połączenia nie zawsze natychmiast kończy się połączenie transportu lub połączenia SignalR, jak opisano w dalszej części tego tematu.</span><span class="sxs-lookup"><span data-stu-id="93fc6-151">However, breaking the physical connection doesn't always immediately end the transport connection or the SignalR connection, as will be explained later in this topic.</span></span>

<span data-ttu-id="93fc6-152">Na poniższym diagramie połączenia SignalR jest reprezentowany przez koncentratory interfejsu API i PersistentConnection API SignalR warstwy połączenie transportu jest reprezentowany przez warstwę transportu i fizyczne połączenie jest reprezentowane przez linie między serwerem a klientami.</span><span class="sxs-lookup"><span data-stu-id="93fc6-152">In the following diagram, the SignalR connection is represented by the Hubs API and PersistentConnection API SignalR layer, the transport connection is represented by the Transports layer, and the physical connection is represented by the lines between the server and the clients.</span></span>

![Diagram architektury usługi SignalR](handling-connection-lifetime-events/_static/image1.png)

<span data-ttu-id="93fc6-154">Gdy wywołujesz `Start` metody w kliencie SignalR, udostępniasz kod klienta SignalR wszystkie informacje, ile potrzebuje, aby ustanowić fizyczne połączenie z serwerem.</span><span class="sxs-lookup"><span data-stu-id="93fc6-154">When you call the `Start` method in a SignalR client, you are providing SignalR client code with all the information it needs in order to establish a physical connection to a server.</span></span> <span data-ttu-id="93fc6-155">Kod klienta SignalR używa tych informacji do przesyłania żądania HTTP i ustanowić połączenie fizycznej za pomocą jednej z metod transportu cztery.</span><span class="sxs-lookup"><span data-stu-id="93fc6-155">SignalR client code uses this information to make an HTTP request and establish a physical connection that uses one of the four transport methods.</span></span> <span data-ttu-id="93fc6-156">Jeśli połączenie transportu nie powiedzie się lub serwer nie powiedzie się, połączenia SignalR nie działa natychmiast od razu, ponieważ klient nadal zawiera informacje potrzebne do automatycznego ponownego nawiązywania nowego połączenia transportu do tego samego adresu URL SignalR.</span><span class="sxs-lookup"><span data-stu-id="93fc6-156">If the transport connection fails or the server fails, the SignalR connection doesn't go away immediately because the client still has the information it needs to automatically re-establish a new transport connection to the same SignalR URL.</span></span> <span data-ttu-id="93fc6-157">W tym scenariuszu nie interwencji z aplikacji użytkownika jest używana, a gdy kod klienta SignalR ustanawia nowego połączenia transportu, nie rozpoczyna nowe połączenia SignalR.</span><span class="sxs-lookup"><span data-stu-id="93fc6-157">In this scenario, no intervention from the user application is involved, and when the SignalR client code establishes a new transport connection, it does not start a new SignalR connection.</span></span> <span data-ttu-id="93fc6-158">Ciągłość działania połączenia SignalR znajduje odzwierciedlenie w rzeczywistości, identyfikator połączenia, który jest tworzony podczas wywoływania `Start` metody nie zmienia się.</span><span class="sxs-lookup"><span data-stu-id="93fc6-158">The continuity of the SignalR connection is reflected in the fact that the connection ID, which is created when you call the `Start` method, does not change.</span></span>

<span data-ttu-id="93fc6-159">`OnReconnected` Program obsługi zdarzeń w Centrum wykonuje podczas transportu ponownym nawiązaniu połączenia automatycznie po została utracona.</span><span class="sxs-lookup"><span data-stu-id="93fc6-159">The `OnReconnected` event handler on the Hub executes when a transport connection is automatically re-established after having been lost.</span></span> <span data-ttu-id="93fc6-160">`OnDisconnected` Program obsługi zdarzeń uruchamia się na końcu połączenia SignalR.</span><span class="sxs-lookup"><span data-stu-id="93fc6-160">The `OnDisconnected` event handler executes at the end of a SignalR connection.</span></span> <span data-ttu-id="93fc6-161">Połączenia SignalR można zakończyć w dowolnym z następujących sposobów:</span><span class="sxs-lookup"><span data-stu-id="93fc6-161">A SignalR connection can end in any of the following ways:</span></span>

- <span data-ttu-id="93fc6-162">Jeśli klient wywołuje `Stop` metody, komunikat o zatrzymaniu są wysyłane do serwera i klienta i serwera zakończenia połączenia SignalR natychmiast.</span><span class="sxs-lookup"><span data-stu-id="93fc6-162">If the client calls the `Stop` method, a stop message is sent to the server, and both client and server end the SignalR connection immediately.</span></span>
- <span data-ttu-id="93fc6-163">Po utraty łączności między klientem i serwerem klient próbuje połączyć, a serwer oczekuje na klienta w celu ponownego nawiązania połączenia.</span><span class="sxs-lookup"><span data-stu-id="93fc6-163">After connectivity between client and server is lost, the client tries to reconnect and the server waits for the client to reconnect.</span></span> <span data-ttu-id="93fc6-164">Jeśli prób ponownego połączenia nie zakończy się pomyślnie, a kończy się w określonym przedziale czasu rozłączenia, klienta i serwera zakończenia połączenia SignalR.</span><span class="sxs-lookup"><span data-stu-id="93fc6-164">If the attempts to reconnect are unsuccessful and the disconnect timeout period ends, both client and server end the SignalR connection.</span></span> <span data-ttu-id="93fc6-165">Zatrzymuje się próby nawiązania ponownego połączenia klienta i serwera usuwa jego reprezentację połączenia SignalR.</span><span class="sxs-lookup"><span data-stu-id="93fc6-165">The client stops trying to reconnect, and the server disposes of its representation of the SignalR connection.</span></span>
- <span data-ttu-id="93fc6-166">Jeśli klient zostanie zatrzymana, bez szansę, aby wywołać `Stop` metody dla klienta w celu ponownego nawiązania połączenia, czeka serwer, a następnie kończy połączenia SignalR, po upływie limitu czasu rozłączenia.</span><span class="sxs-lookup"><span data-stu-id="93fc6-166">If the client stops running without having a chance to call the `Stop` method, the server waits for the client to reconnect, and then ends the SignalR connection after the disconnect timeout period.</span></span>
- <span data-ttu-id="93fc6-167">Jeśli zatrzymuje serwera, uruchamianie, klient próbuje ponownie połączyć (ponownie utworzyć połączenia transportowego), a następnie kończy połączenia SignalR, po upływie limitu czasu rozłączenia.</span><span class="sxs-lookup"><span data-stu-id="93fc6-167">If the server stops running, the client tries to reconnect (re-create the transport connection), and then ends the SignalR connection after the disconnect timeout period.</span></span>

<span data-ttu-id="93fc6-168">Gdy nie ma żadnych problemów połączenia i aplikacji użytkownika kończy się połączenia SignalR, wywołując `Stop` metody, połączenia SignalR i połączenie transportu rozpocząć i zakończyć w tym samym czasie.</span><span class="sxs-lookup"><span data-stu-id="93fc6-168">When there are no connection problems, and the user application ends the SignalR connection by calling the `Stop` method, the SignalR connection and the transport connection begin and end at about the same time.</span></span> <span data-ttu-id="93fc6-169">Poniższe sekcje bardziej szczegółowo opisano inne scenariusze.</span><span class="sxs-lookup"><span data-stu-id="93fc6-169">The following sections describe in more detail the other scenarios.</span></span>

<a id="transportdisconnect"></a>

### <a name="transport-disconnection-scenarios"></a><span data-ttu-id="93fc6-170">Scenariusze rozłączenia transportu</span><span class="sxs-lookup"><span data-stu-id="93fc6-170">Transport disconnection scenarios</span></span>

<span data-ttu-id="93fc6-171">Fizyczne połączenia może być wolne lub mogą wystąpić zakłócenia w łączności.</span><span class="sxs-lookup"><span data-stu-id="93fc6-171">Physical connections might be slow or there might be interruptions in connectivity.</span></span> <span data-ttu-id="93fc6-172">W zależności od takich czynników, takich jak długość przerwania mogą być opuszczane połączenie transportu.</span><span class="sxs-lookup"><span data-stu-id="93fc6-172">Depending on factors such as the length of the interruption, the transport connection might be dropped.</span></span> <span data-ttu-id="93fc6-173">SignalR próbuje ponownie ustanowić połączenie transportu.</span><span class="sxs-lookup"><span data-stu-id="93fc6-173">SignalR then tries to re-establish the transport connection.</span></span> <span data-ttu-id="93fc6-174">Czasami interfejs API połączenia transportu wykrywa czas przestoju i odrzuca połączenie transportu i SignalR dowiaduje się natychmiast, połączenie zostanie przerwane.</span><span class="sxs-lookup"><span data-stu-id="93fc6-174">Sometimes the transport connection API detects the interruption and drops the transport connection, and SignalR finds out immediately that the connection is lost.</span></span> <span data-ttu-id="93fc6-175">W innych scenariuszach interfejs API połączenia transportu ani SignalR uświadamia sobie, natychmiastowe połączenie zostało utracone.</span><span class="sxs-lookup"><span data-stu-id="93fc6-175">In other scenarios, neither the transport connection API nor SignalR becomes aware immediately that connectivity has been lost.</span></span> <span data-ttu-id="93fc6-176">Dla wszystkich transportów na z wyjątkiem długiego sondowania klienta SignalR używa funkcji o nazwie *keepalive* pod kątem utraty łączności transportu interfejsu API nie jest w stanie wykryć.</span><span class="sxs-lookup"><span data-stu-id="93fc6-176">For all transports except long polling, the SignalR client uses a function called *keepalive* to check for loss of connectivity that the transport API is unable to detect.</span></span> <span data-ttu-id="93fc6-177">Aby uzyskać informacji na temat długo sondowania połączeń, zobacz [ustawienia limitu czasu i utrzymywania aktywności](#timeoutkeepalive) w dalszej części tego tematu.</span><span class="sxs-lookup"><span data-stu-id="93fc6-177">For information about long polling connections, see [Timeout and keepalive settings](#timeoutkeepalive) later in this topic.</span></span>

<span data-ttu-id="93fc6-178">Gdy połączenie jest nieaktywny, okresowo serwer wysyła pakiet keepalive do klienta.</span><span class="sxs-lookup"><span data-stu-id="93fc6-178">When a connection is inactive, periodically the server sends a keepalive packet to the client.</span></span> <span data-ttu-id="93fc6-179">Począwszy od daty, który jest zapisywany w tym artykule domyślna częstotliwość to co 10 sekund.</span><span class="sxs-lookup"><span data-stu-id="93fc6-179">As of the date this article is being written, the default frequency is every 10 seconds.</span></span> <span data-ttu-id="93fc6-180">Przez nasłuchiwanie dla tych pakietów, klientów można określić, czy występuje problem z połączeniem.</span><span class="sxs-lookup"><span data-stu-id="93fc6-180">By listening for these packets, clients can tell if there is a connection problem.</span></span> <span data-ttu-id="93fc6-181">Jeśli nie zostanie odebrany pakiet keepalive, gdy oczekiwano, po pewnym czasie klient przyjmie założenie, że nie istnieją problemy z połączeniem takich jak powolność lub przerw w działaniu.</span><span class="sxs-lookup"><span data-stu-id="93fc6-181">If a keepalive packet is not received when expected, after a short time the client assumes that there are connection problems such as slowness or interruptions.</span></span> <span data-ttu-id="93fc6-182">Jeśli keepalive nadal nie zostanie odebrany po dłuższy czas, klient przyjmie założenie, że połączenie zostało porzucone, a jego rozpoczęciem próby nawiązania ponownego połączenia.</span><span class="sxs-lookup"><span data-stu-id="93fc6-182">If the keepalive is still not received after a longer time, the client assumes that the connection has been dropped, and it begins trying to reconnect.</span></span>

<span data-ttu-id="93fc6-183">Na poniższym diagramie przedstawiono zdarzeń klienta i serwera, które są wywoływane w typowym scenariuszu, gdy występują problemy z fizycznego połączenia, które natychmiast nie są rozpoznawane przez transportu interfejsu API.</span><span class="sxs-lookup"><span data-stu-id="93fc6-183">The following diagram illustrates the client and server events that are raised in a typical scenario when there are problems with the physical connection that aren't immediately recognized by the transport API.</span></span> <span data-ttu-id="93fc6-184">Diagram ma zastosowanie do następujących okolicznościach:</span><span class="sxs-lookup"><span data-stu-id="93fc6-184">The diagram applies to the following circumstances:</span></span>

- <span data-ttu-id="93fc6-185">Transport jest WebSockets, nieskończoność ramkę lub zdarzenia wysłanego przez serwer.</span><span class="sxs-lookup"><span data-stu-id="93fc6-185">The transport is WebSockets, forever frame, or server-sent events.</span></span>
- <span data-ttu-id="93fc6-186">Istnieją różne okresy przerwy w połączeniu sieci fizycznej.</span><span class="sxs-lookup"><span data-stu-id="93fc6-186">There are varying periods of interruption in the physical network connection.</span></span>
- <span data-ttu-id="93fc6-187">Transport interfejsu API nie zostaną powiadomieni o przerwami w działaniu, dzięki czemu SignalR opiera się na funkcjach keepalive w celu jego wykrycia.</span><span class="sxs-lookup"><span data-stu-id="93fc6-187">The transport API does not become aware of the interruptions, so SignalR relies on the keepalive functionality to detect them.</span></span>

![Odłączenia transportu](handling-connection-lifetime-events/_static/image2.png)

<span data-ttu-id="93fc6-189">Jeśli klient przechodzi do ponownego połączenia trybu, ale nie można ustanowić połączenia transportu, w ramach limit czasu rozłączenia, serwer kończy połączenia SignalR.</span><span class="sxs-lookup"><span data-stu-id="93fc6-189">If the client goes into reconnecting mode but can't establish a transport connection within the disconnect timeout limit, the server terminates the SignalR connection.</span></span> <span data-ttu-id="93fc6-190">Jeśli tak się stanie, serwer wykonuje Centrum `OnDisconnected` metody i kolejki rozłączenia komunikat do wysłania do klienta, w przypadku, gdy klient zarządza połączyć się później.</span><span class="sxs-lookup"><span data-stu-id="93fc6-190">When that happens, the server executes the Hub's `OnDisconnected` method and queues up a disconnect message to send to the client in case the client manages to connect later.</span></span> <span data-ttu-id="93fc6-191">Jeśli klient ponowne, odbierze polecenie rozłączenia i wywołania `Stop` metody.</span><span class="sxs-lookup"><span data-stu-id="93fc6-191">If the client then does reconnect, it receives the disconnect command and calls the `Stop` method.</span></span> <span data-ttu-id="93fc6-192">W tym scenariuszu `OnReconnected` nie jest wykonywany, gdy klient ponownie nawiąże połączenie, i `OnDisconnected` nie jest wykonywany, gdy klient wywołuje `Stop`.</span><span class="sxs-lookup"><span data-stu-id="93fc6-192">In this scenario, `OnReconnected` is not executed when the client reconnects, and `OnDisconnected` is not executed when the client calls `Stop`.</span></span> <span data-ttu-id="93fc6-193">Na poniższym diagramie przedstawiono w tym scenariuszu.</span><span class="sxs-lookup"><span data-stu-id="93fc6-193">The following diagram illustrates this scenario.</span></span>

![Zakłócenia transportu — limit czasu serwera](handling-connection-lifetime-events/_static/image3.png)

<span data-ttu-id="93fc6-195">Zdarzenia okresu istnienia połączenia SignalR, które mogą być wywoływane na komputerze klienckim, są następujące:</span><span class="sxs-lookup"><span data-stu-id="93fc6-195">The SignalR connection lifetime events that may be raised on the client are the following:</span></span>

- `ConnectionSlow` <span data-ttu-id="93fc6-196">Zdarzenie klienta.</span><span class="sxs-lookup"><span data-stu-id="93fc6-196">client event.</span></span>

    <span data-ttu-id="93fc6-197">Wywoływane, gdy wstępnie zdefiniowane część keepalive limit czasu minęło od czasu ostatniego komunikatu lub keepalive ping zostało przesłane.</span><span class="sxs-lookup"><span data-stu-id="93fc6-197">Raised when a preset proportion of the keepalive timeout period has passed since the last message or keepalive ping was received.</span></span> <span data-ttu-id="93fc6-198">Domyślny okres ostrzeżenie limitu czasu utrzymywania aktywności jest 2/3 limitu czasu utrzymywania aktywności.</span><span class="sxs-lookup"><span data-stu-id="93fc6-198">The default keepalive timeout warning period is 2/3 of the keepalive timeout.</span></span> <span data-ttu-id="93fc6-199">Limit czasu utrzymywania aktywności jest 20 sekund, więc ostrzeżenie pojawia się na około 13 sekundach.</span><span class="sxs-lookup"><span data-stu-id="93fc6-199">The keepalive timeout is 20 seconds, so the warning occurs at about 13 seconds.</span></span>

    <span data-ttu-id="93fc6-200">Domyślnie serwer wysyła pakiety ping keepalive co 10 sekund, a klient sprawdza, czy pakiety utrzymywania aktywności o co 2 sekundy (1/3 różnicy między wartością limitu czasu keepalive keepalive wartość Ostrzeżenie limitu czasu).</span><span class="sxs-lookup"><span data-stu-id="93fc6-200">By default, the server sends keepalive pings every 10 seconds, and the client checks for keepalive pings about every 2 seconds (one third of the difference between the keepalive timeout value and the keepalive timeout warning value).</span></span>

    <span data-ttu-id="93fc6-201">Jeśli interfejs API transportu uzyska informacje o rozłączeniu, SignalR może informowany o odłączenie przed przekazuje okres ostrzeżenie limitu czasu utrzymywania aktywności.</span><span class="sxs-lookup"><span data-stu-id="93fc6-201">If the transport API becomes aware of a disconnection, SignalR might be informed of the disconnection before the keepalive timeout warning period passes.</span></span> <span data-ttu-id="93fc6-202">W takim przypadku `ConnectionSlow` zdarzenie nie będzie wywoływane i SignalR musieli przejść bezpośrednio do `Reconnecting` zdarzeń.</span><span class="sxs-lookup"><span data-stu-id="93fc6-202">In that case, the `ConnectionSlow` event would not be raised, and SignalR would go directly to the `Reconnecting` event.</span></span>
- `Reconnecting` <span data-ttu-id="93fc6-203">Zdarzenie klienta.</span><span class="sxs-lookup"><span data-stu-id="93fc6-203">client event.</span></span>

    <span data-ttu-id="93fc6-204">Wywoływane, gdy (transportu interfejsu API wykryje, czy połączenie zostało utracone lub (b) keepalive limitu czasu minęło od czasu ostatniego komunikatu lub keepalive ping zostało przesłane.</span><span class="sxs-lookup"><span data-stu-id="93fc6-204">Raised when (a) the transport API detects that the connection is lost, or (b) the keepalive timeout period has passed since the last message or keepalive ping was received.</span></span> <span data-ttu-id="93fc6-205">Kod klienta SignalR podejmuje próbę ponownego połączenia.</span><span class="sxs-lookup"><span data-stu-id="93fc6-205">The SignalR client code begins trying to reconnect.</span></span> <span data-ttu-id="93fc6-206">To zdarzenie może obsłużyć, jeśli chcesz, aby aplikacja wykonania określonego działania, gdy transport połączenie zostanie przerwane.</span><span class="sxs-lookup"><span data-stu-id="93fc6-206">You can handle this event if you want your application to take some action when a transport connection is lost.</span></span> <span data-ttu-id="93fc6-207">Domyślny okres limitu czasu utrzymywania aktywności jest obecnie 20 sekund.</span><span class="sxs-lookup"><span data-stu-id="93fc6-207">The default keepalive timeout period is currently 20 seconds.</span></span>

    <span data-ttu-id="93fc6-208">Jeśli kod klienta próbuje wywołać metodę koncentratora, gdy trwa ponowne nawiązywanie połączenia trybu SignalR, SignalR spróbuj wysłać polecenie.</span><span class="sxs-lookup"><span data-stu-id="93fc6-208">If your client code tries to call a Hub method while SignalR is in reconnecting mode, SignalR will try to send the command.</span></span> <span data-ttu-id="93fc6-209">W większości przypadków, takie próby zakończą się niepowodzeniem, ale w niektórych sytuacjach może się powieść.</span><span class="sxs-lookup"><span data-stu-id="93fc6-209">Most of the time, such attempts will fail, but in some circumstances they might succeed.</span></span> <span data-ttu-id="93fc6-210">Serwer wysłał zdarzenia, nieskończoność ramki i długi transport sondowania SignalR używa dwa kanały komunikacyjne: jeden, używanego przez klienta do wysyłania komunikatów i jeden, używaną do odbierania komunikatów.</span><span class="sxs-lookup"><span data-stu-id="93fc6-210">For the server-sent events, forever frame, and long polling transports, SignalR uses two communication channels, one that the client uses to send messages and one that it uses to receive messages.</span></span> <span data-ttu-id="93fc6-211">Kanał używany do odbierania jest stale otwarte i jest ten, który jest zamykane, gdy fizyczne połączenie zostanie przerwane.</span><span class="sxs-lookup"><span data-stu-id="93fc6-211">The channel used for receiving is the permanently open one, and that's the one that is closed when the physical connection is interrupted.</span></span> <span data-ttu-id="93fc6-212">Kanał, używane na potrzeby wysyłania pozostaje dostępna, więc jeśli zostanie przywrócona fizycznej łączności, wywołanie metody z klienta do serwera może zakończyć się pomyślnie przed kanału receive zostanie ponownie nawiązane.</span><span class="sxs-lookup"><span data-stu-id="93fc6-212">The channel used for sending remains available, so if physical connectivity is restored, a method call from client to server might be successful before the receive channel is re-established.</span></span> <span data-ttu-id="93fc6-213">Wartość zwracana nie będą odbierane, dopóki SignalR ponownie zostanie otwarty kanał używany do odbierania.</span><span class="sxs-lookup"><span data-stu-id="93fc6-213">The return value would not be received until SignalR re-opens the channel used for receiving.</span></span>
- `Reconnected` <span data-ttu-id="93fc6-214">Zdarzenie klienta.</span><span class="sxs-lookup"><span data-stu-id="93fc6-214">client event.</span></span>

    <span data-ttu-id="93fc6-215">Wywoływane po ustanowieniu połączenia transportu.</span><span class="sxs-lookup"><span data-stu-id="93fc6-215">Raised when the transport connection is reestablished.</span></span> <span data-ttu-id="93fc6-216">`OnReconnected` Wykonuje program obsługi zdarzeń w Centrum.</span><span class="sxs-lookup"><span data-stu-id="93fc6-216">The `OnReconnected` event handler in the Hub executes.</span></span>
- `Closed` <span data-ttu-id="93fc6-217">Zdarzenie klienta (`disconnected` zdarzeń w języku JavaScript).</span><span class="sxs-lookup"><span data-stu-id="93fc6-217">client event (`disconnected` event in JavaScript).</span></span>

    <span data-ttu-id="93fc6-218">Wywoływane, gdy rozłączenia upłynięcia limitu czasu podczas, gdy kod klienta SignalR jest próby nawiązania ponownego połączenia po utracie połączenia transportu.</span><span class="sxs-lookup"><span data-stu-id="93fc6-218">Raised when the disconnect timeout period expires while the SignalR client code is trying to reconnect after losing the transport connection.</span></span> <span data-ttu-id="93fc6-219">Odłącz domyślny limit czasu wynosi 30 sekund.</span><span class="sxs-lookup"><span data-stu-id="93fc6-219">The default disconnect timeout is 30 seconds.</span></span> <span data-ttu-id="93fc6-220">(To zdarzenie jest również zgłaszane w przypadku połączenia zakończy się, ponieważ `Stop` metoda jest wywoływana.)</span><span class="sxs-lookup"><span data-stu-id="93fc6-220">(This event is also raised when the connection ends because the `Stop` method is called.)</span></span>

<span data-ttu-id="93fc6-221">Transport połączenia przerw w działaniu, które nie są wykrywane przez transportu interfejsu API i nie zwlekaj odbiór keepalive ping z serwera przez czas dłuższy niż limit czasu ostrzeżenia keepalive nie spowodować dowolnego połączenia, zdarzenia okresu istnienia zgłoszenie.</span><span class="sxs-lookup"><span data-stu-id="93fc6-221">Transport connection interruptions that are not detected by the transport API and don't delay the reception of keepalive pings from the server for longer than the keepalive timeout warning period might not cause any connection lifetime events to be raised.</span></span>

<span data-ttu-id="93fc6-222">Niektóre środowiska sieciowe celowo Zamknij bezczynnych połączeń, a inną funkcję pakiety utrzymywania aktywności jest aby temu zapobiec, dzięki czemu będzie tych sieciach wiedzieć, że połączenia SignalR jest używany.</span><span class="sxs-lookup"><span data-stu-id="93fc6-222">Some network environments deliberately close idle connections, and another function of the keepalive packets is to help prevent this by letting these networks know that a SignalR connection is in use.</span></span> <span data-ttu-id="93fc6-223">W skrajnych przypadkach domyślnej częstotliwości równej keepalive ping może nie być wystarczające, aby zapobiec zamkniętego połączenia.</span><span class="sxs-lookup"><span data-stu-id="93fc6-223">In extreme cases the default frequency of keepalive pings might not be enough to prevent closed connections.</span></span> <span data-ttu-id="93fc6-224">W takim przypadku można skonfigurować keepalive ping do wysłania częściej.</span><span class="sxs-lookup"><span data-stu-id="93fc6-224">In that case you can configure keepalive pings to be sent more often.</span></span> <span data-ttu-id="93fc6-225">Aby uzyskać więcej informacji, zobacz [ustawienia limitu czasu i utrzymywania aktywności](#timeoutkeepalive) w dalszej części tego tematu.</span><span class="sxs-lookup"><span data-stu-id="93fc6-225">For more information, see [Timeout and keepalive settings](#timeoutkeepalive) later in this topic.</span></span>

> [!NOTE]
>
> <span data-ttu-id="93fc6-226">**Ważne**: Kolejność zdarzeń opisane w tym miejscu nie jest gwarantowana.</span><span class="sxs-lookup"><span data-stu-id="93fc6-226">**Important**: The sequence of events described here is not guaranteed.</span></span> <span data-ttu-id="93fc6-227">SignalR sprawia, że każda próba zgłaszać zdarzenia okresu istnienia połączenia w sposób przewidywalny zgodnie z tym schemacie, ale istnieją wielu wariantów zdarzenia sieci i wiele sposobów, w których podstawowych struktur komunikacji, takich jak transportu interfejsy API z je obsłużyć.</span><span class="sxs-lookup"><span data-stu-id="93fc6-227">SignalR makes every attempt to raise connection lifetime events in a predictable manner according to this scheme, but there are many variations of network events and many ways in which underlying communications frameworks such as transport APIs handle them.</span></span> <span data-ttu-id="93fc6-228">Na przykład `Reconnected` zdarzeń nie może zostać wywołane, gdy klient ponownie nawiąże połączenie, lub `OnConnected` obsługi na serwerze może być uruchomiony, gdy próba nawiązania połączenia zakończy się niepowodzeniem.</span><span class="sxs-lookup"><span data-stu-id="93fc6-228">For example, the `Reconnected` event might not be raised when the client reconnects, or the `OnConnected` handler on the server might run when the attempt to establish a connection is unsuccessful.</span></span> <span data-ttu-id="93fc6-229">W tym temacie opisano tylko efekty, zwykle produkcji przez niektórych typowych okolicznościach.</span><span class="sxs-lookup"><span data-stu-id="93fc6-229">This topic describes only the effects that would normally be produced by certain typical circumstances.</span></span>


<a id="clientdisconnect"></a>

### <a name="client-disconnection-scenarios"></a><span data-ttu-id="93fc6-230">Scenariusze rozłączenia klienta</span><span class="sxs-lookup"><span data-stu-id="93fc6-230">Client disconnection scenarios</span></span>

<span data-ttu-id="93fc6-231">W kliencie przeglądarki kod klienta SignalR, który obsługuje połączenia SignalR jest uruchamiany w kontekście JavaScript, strony sieci web.</span><span class="sxs-lookup"><span data-stu-id="93fc6-231">In a browser client, the SignalR client code that maintains a SignalR connection runs in the JavaScript context of a web page.</span></span> <span data-ttu-id="93fc6-232">Który ma Dlaczego musi się kończyć, kiedy przejść z jednego połączenia SignalR strony do innej, a także że użytkownika dlaczego masz wiele połączeń z wielu identyfikatorów połączeń. Jeśli łączysz się z wielu okna przeglądarki lub karty.</span><span class="sxs-lookup"><span data-stu-id="93fc6-232">That's why the SignalR connection has to end when you navigate from one page to another, and that's why you have multiple connections with multiple connection IDs if you connect from multiple browser windows or tabs.</span></span> <span data-ttu-id="93fc6-233">Gdy użytkownik zamyka okna lub karty przeglądarki, lub przechodzi do nowej strony lub odświeża stronę, połączenia SignalR natychmiast zakończy się, ponieważ kod klienta SignalR zdarzenie przeglądarka obsługuje i wywołuje `Stop` metody.</span><span class="sxs-lookup"><span data-stu-id="93fc6-233">When the user closes a browser window or tab, or navigates to a new page or refreshes the page, the SignalR connection immediately ends because SignalR client code handles that browser event for you and calls the `Stop` method.</span></span> <span data-ttu-id="93fc6-234">W tych scenariuszach lub dowolnej platformie klienta, gdy Twoja aplikacja wywołuje `Stop` metody `OnDisconnected` programu obsługi zdarzeń jest wykonywana bezpośrednio na serwerze, i zgłasza klienta `Closed` zdarzeń (zdarzenie jest nazywane `disconnected` w JavaScript).</span><span class="sxs-lookup"><span data-stu-id="93fc6-234">In these scenarios, or in any client platform when your application calls the `Stop` method, the `OnDisconnected` event handler executes immediately on the server and the client raises the `Closed` event (the event is named `disconnected` in JavaScript).</span></span>

<span data-ttu-id="93fc6-235">Jeśli aplikacja kliencka lub komputera, na którym jest uruchomiona na awarie lub przechodzi w stan uśpienia (na przykład, gdy użytkownik zamknie komputera przenośnego), serwer nie jest informowany o co się stało.</span><span class="sxs-lookup"><span data-stu-id="93fc6-235">If a client application or the computer that it's running on crashes or goes to sleep (for example, when the user closes the laptop), the server is not informed about what happened.</span></span> <span data-ttu-id="93fc6-236">Chodzi o serwer żądał, utrata klienta może wynikać ze przerwanie łączności i klienta może być próby nawiązania ponownego połączenia.</span><span class="sxs-lookup"><span data-stu-id="93fc6-236">As far as the server knows, the loss of the client might be due to connectivity interruption and the client might be trying to reconnect.</span></span> <span data-ttu-id="93fc6-237">Dlatego w tych scenariuszach, czeka serwer, aby zaoferować klientowi produkt szansę, aby połączyć ponownie a `OnDisconnected` nie jest wykonywane do momentu rozłączenia upłynięcia limitu czasu (około 30 sekund domyślnie).</span><span class="sxs-lookup"><span data-stu-id="93fc6-237">Therefore, in these scenarios the server waits to give the client a chance to reconnect, and `OnDisconnected` does not execute until the disconnect timeout period expires (about 30 seconds by default).</span></span> <span data-ttu-id="93fc6-238">Na poniższym diagramie przedstawiono w tym scenariuszu.</span><span class="sxs-lookup"><span data-stu-id="93fc6-238">The following diagram illustrates this scenario.</span></span>

![Niepowodzenie komputera klienta](handling-connection-lifetime-events/_static/image4.png)

<a id="serverdisconnect"></a>

### <a name="server-disconnection-scenarios"></a><span data-ttu-id="93fc6-240">Scenariusze odłączenia serwera</span><span class="sxs-lookup"><span data-stu-id="93fc6-240">Server disconnection scenarios</span></span>

<span data-ttu-id="93fc6-241">Gdy serwer przejdzie do trybu offline — ponowne uruchomienie, zakończy się niepowodzeniem, domena aplikacji odtwarzanie itd. — wynik może być podobny do utracono połączenie lub transportu interfejsu API i SignalR może od razu wiedzieć, że serwer został usunięty, a SignalR może zacząć próby nawiązania ponownego połączenia bez wywoływanie `ConnectionSlow` zdarzeń.</span><span class="sxs-lookup"><span data-stu-id="93fc6-241">When a server goes offline -- it reboots, fails, the app domain recycles, etc. -- the result might be similar to a lost connection, or the transport API and SignalR might know immediately that the server is gone, and SignalR might begin trying to reconnect without raising the `ConnectionSlow` event.</span></span> <span data-ttu-id="93fc6-242">Jeśli klient przechodzi do ponownego połączenia trybu i odzyskuje serwer lub ponownego uruchamiania lub nowy serwer w tryb online przed upływem limitu czasu rozłączenia, klient nawiąże połączenie do przywróconej lub nowego serwera.</span><span class="sxs-lookup"><span data-stu-id="93fc6-242">If the client goes into reconnecting mode, and if the server recovers or restarts or a new server is brought online before the disconnect timeout period expires, the client will reconnect to the restored or new server.</span></span> <span data-ttu-id="93fc6-243">W takim przypadku nadal połączenia SignalR na komputerze klienckim i `Reconnected` zdarzenie jest wywoływane.</span><span class="sxs-lookup"><span data-stu-id="93fc6-243">In that case, the SignalR connection continues on the client and the `Reconnected` event is raised.</span></span> <span data-ttu-id="93fc6-244">Na pierwszym serwerze `OnDisconnected` nigdy nie jest wykonywane i na nowym serwerze `OnReconnected` jest wykonywany, mimo że `OnConnected` nigdy nie została wykonana dla tego klienta na tym serwerze przed.</span><span class="sxs-lookup"><span data-stu-id="93fc6-244">On the first server, `OnDisconnected` is never executed, and on the new server, `OnReconnected` is executed although `OnConnected` was never executed for that client on that server before.</span></span> <span data-ttu-id="93fc6-245">(Efekt jest taki sam, gdy klient ponownie nawiąże połączenie z tym samym serwerem po ponownym uruchomieniu lub aplikacji domeny, ponieważ po ponownym uruchomieniu serwera go ma Brak pamięci działania poprzednie połączenie.) Poniższy diagram przyjęto założenie, że transportu interfejsu API uzyska informacje o utracie połączenia natychmiast, więc `ConnectionSlow` zdarzenie jest zgłaszane w nie.</span><span class="sxs-lookup"><span data-stu-id="93fc6-245">(The effect is the same if the client reconnects to the same server after a reboot or app domain recycle, because when the server restarts it has no memory of prior connection activity.) The following diagram assumes that the transport API becomes aware of the lost connection immediately, so the `ConnectionSlow` event is not raised.</span></span>

![Awaria serwera i ponowne nawiązanie połączenia](handling-connection-lifetime-events/_static/image5.png)

<span data-ttu-id="93fc6-247">Jeśli serwer nie są dostępne przed upływem limitu czasu rozłączenia, kończy się połączenia SignalR.</span><span class="sxs-lookup"><span data-stu-id="93fc6-247">If a server does not become available within the disconnect timeout period, the SignalR connection ends.</span></span> <span data-ttu-id="93fc6-248">W tym scenariuszu `Closed` zdarzeń (`disconnected` w klientów języka JavaScript) jest uruchamiany na komputerze klienckim, ale `OnDisconnected` nigdy nie jest wywoływana na serwerze.</span><span class="sxs-lookup"><span data-stu-id="93fc6-248">In this scenario, the `Closed` event (`disconnected` in JavaScript clients) is raised on the client but `OnDisconnected` is never called on the server.</span></span> <span data-ttu-id="93fc6-249">Poniższy diagram przyjęto założenie, że transportu interfejsu API nie zostaną powiadomieni o utracono połączenie, zostanie on wykryty przez funkcje keepalive SignalR i `ConnectionSlow` zdarzenie jest wywoływane.</span><span class="sxs-lookup"><span data-stu-id="93fc6-249">The following diagram assumes that the transport API does not become aware of the lost connection, so it is detected by SignalR keepalive functionality and the `ConnectionSlow` event is raised.</span></span>

![Awaria serwera i limitu czasu](handling-connection-lifetime-events/_static/image6.png)

<a id="timeoutkeepalive"></a>

## <a name="timeout-and-keepalive-settings"></a><span data-ttu-id="93fc6-251">Ustawienia limitu czasu i utrzymywania aktywności</span><span class="sxs-lookup"><span data-stu-id="93fc6-251">Timeout and keepalive settings</span></span>

<span data-ttu-id="93fc6-252">Wartość domyślna `ConnectionTimeout`, `DisconnectTimeout`, i `KeepAlive` wartości są odpowiednie dla większości scenariuszy, ale można ją zmienić, jeśli w środowisku zawierającym specjalnymi potrzebami.</span><span class="sxs-lookup"><span data-stu-id="93fc6-252">The default `ConnectionTimeout`, `DisconnectTimeout`, and `KeepAlive` values are appropriate for most scenarios but can be changed if your environment has special needs.</span></span> <span data-ttu-id="93fc6-253">Na przykład jeśli środowisko sieciowe zamyka połączenia, które są w stanie bezczynności przez 5 sekund, może być konieczne Zmniejsz wartość utrzymywania aktywności.</span><span class="sxs-lookup"><span data-stu-id="93fc6-253">For example, if your network environment closes connections that are idle for 5 seconds, you might have to decrease the keepalive value.</span></span>

<a id="connectiontimeout"></a>

### <a name="connectiontimeout"></a><span data-ttu-id="93fc6-254">ConnectionTimeout</span><span class="sxs-lookup"><span data-stu-id="93fc6-254">ConnectionTimeout</span></span>

<span data-ttu-id="93fc6-255">To ustawienie oznacza ilość czasu, aby pozostawić połączenie transportu, Otwórz i oczekuje na odpowiedź przed jego zamknięciem i otwarciem nowego połączenia.</span><span class="sxs-lookup"><span data-stu-id="93fc6-255">This setting represents the amount of time to leave a transport connection open and waiting for a response before closing it and opening a new connection.</span></span> <span data-ttu-id="93fc6-256">Wartość domyślna wynosi 110 sekund.</span><span class="sxs-lookup"><span data-stu-id="93fc6-256">The default value is 110 seconds.</span></span>

<span data-ttu-id="93fc6-257">To ustawienie dotyczy tylko kiedy keepalive funkcja jest wyłączona, co zwykle ma zastosowanie tylko długiego transportu sondowania.</span><span class="sxs-lookup"><span data-stu-id="93fc6-257">This setting applies only when keepalive functionality is disabled, which normally applies only to the long polling transport.</span></span> <span data-ttu-id="93fc6-258">Na poniższym diagramie przedstawiono efekt tego ustawienia, na czas sondowania połączenie transportu.</span><span class="sxs-lookup"><span data-stu-id="93fc6-258">The following diagram illustrates the effect of this setting on a long polling transport connection.</span></span>

![Czas połączenia transportu sondowania](handling-connection-lifetime-events/_static/image7.png)

<a id="disconnecttimeout"></a>

### <a name="disconnecttimeout"></a><span data-ttu-id="93fc6-260">DisconnectTimeout</span><span class="sxs-lookup"><span data-stu-id="93fc6-260">DisconnectTimeout</span></span>

<span data-ttu-id="93fc6-261">To ustawienie oznacza ilość czasu połączenia transportu są tracone przed zgłoszeniem `Disconnected` zdarzeń.</span><span class="sxs-lookup"><span data-stu-id="93fc6-261">This setting represents the amount of time to wait after a transport connection is lost before raising the `Disconnected` event.</span></span> <span data-ttu-id="93fc6-262">Wartość domyślna to 30 sekund.</span><span class="sxs-lookup"><span data-stu-id="93fc6-262">The default value is 30 seconds.</span></span> <span data-ttu-id="93fc6-263">Po ustawieniu `DisconnectTimeout`, `KeepAlive` jest automatycznie ustawiona na 1/3 `DisconnectTimeout` wartość.</span><span class="sxs-lookup"><span data-stu-id="93fc6-263">When you set `DisconnectTimeout`, `KeepAlive` is automatically set to 1/3 of the `DisconnectTimeout` value.</span></span>

<a id="keepalive"></a>

### <a name="keepalive"></a><span data-ttu-id="93fc6-264">KeepAlive</span><span class="sxs-lookup"><span data-stu-id="93fc6-264">KeepAlive</span></span>

<span data-ttu-id="93fc6-265">To ustawienie oznacza ilość czasu oczekiwania przed wysłaniem pakietu keepalive bezczynnego połączenia.</span><span class="sxs-lookup"><span data-stu-id="93fc6-265">This setting represents the amount of time to wait before sending a keepalive packet over an idle connection.</span></span> <span data-ttu-id="93fc6-266">Wartość domyślna to 10 sekund.</span><span class="sxs-lookup"><span data-stu-id="93fc6-266">The default value is 10 seconds.</span></span> <span data-ttu-id="93fc6-267">Ta wartość nie może być więcej niż 1/3 `DisconnectTimeout` wartość.</span><span class="sxs-lookup"><span data-stu-id="93fc6-267">This value must not be more than 1/3 of the `DisconnectTimeout` value.</span></span>

<span data-ttu-id="93fc6-268">Jeśli chcesz ustawić zarówno `DisconnectTimeout` i `KeepAlive`ustaw `KeepAlive` po `DisconnectTimeout`.</span><span class="sxs-lookup"><span data-stu-id="93fc6-268">If you want to set both `DisconnectTimeout` and `KeepAlive`, set `KeepAlive` after `DisconnectTimeout`.</span></span> <span data-ttu-id="93fc6-269">W przeciwnym razie swoje `KeepAlive` ustawienia zostaną zastąpione podczas `DisconnectTimeout` automatycznie ustawia `KeepAlive` 1/3 wartości limitu czasu.</span><span class="sxs-lookup"><span data-stu-id="93fc6-269">Otherwise your `KeepAlive` setting will be overwritten when `DisconnectTimeout` automatically sets `KeepAlive` to 1/3 of the timeout value.</span></span>

<span data-ttu-id="93fc6-270">Jeśli chcesz wyłączyć funkcję keepalive `KeepAlive` na wartość null.</span><span class="sxs-lookup"><span data-stu-id="93fc6-270">If you want to disable keepalive functionality, set `KeepAlive` to null.</span></span> <span data-ttu-id="93fc6-271">Funkcje Keepalive jest automatycznie wyłączana dla długiego transportu sondowania.</span><span class="sxs-lookup"><span data-stu-id="93fc6-271">Keepalive functionality is automatically disabled for the long polling transport.</span></span>

<a id="changetimeout"></a>

### <a name="how-to-change-timeout-and-keepalive-settings"></a><span data-ttu-id="93fc6-272">Jak zmienić ustawienia limitu czasu i utrzymywania aktywności</span><span class="sxs-lookup"><span data-stu-id="93fc6-272">How to change timeout and keepalive settings</span></span>

<span data-ttu-id="93fc6-273">Aby zmienić wartości domyślne dla tych ustawień, należy ustawić je w `Application_Start` w swojej *Global.asax* pliku, jak pokazano w poniższym przykładzie.</span><span class="sxs-lookup"><span data-stu-id="93fc6-273">To change the default values for these settings, set them in `Application_Start` in your *Global.asax* file, as shown in the following example.</span></span> <span data-ttu-id="93fc6-274">Wartości podane w przykładowym kodzie są takie same jak wartości domyślne.</span><span class="sxs-lookup"><span data-stu-id="93fc6-274">The values shown in the sample code are the same as the default values.</span></span>

[!code-csharp[Main](handling-connection-lifetime-events/samples/sample1.cs)]

<a id="notifydisconnect"></a>

## <a name="how-to-notify-the-user-about-disconnections"></a><span data-ttu-id="93fc6-275">Jak powiadamiać użytkownika o odłączenia</span><span class="sxs-lookup"><span data-stu-id="93fc6-275">How to notify the user about disconnections</span></span>

<span data-ttu-id="93fc6-276">W niektórych aplikacjach możesz chcieć wyświetlić komunikat dla użytkownika, gdy występują problemy z łącznością.</span><span class="sxs-lookup"><span data-stu-id="93fc6-276">In some applications you might want to display a message to the user when there are connectivity problems.</span></span> <span data-ttu-id="93fc6-277">Masz kilka opcji, jak i kiedy mają to robić.</span><span class="sxs-lookup"><span data-stu-id="93fc6-277">You have several options for how and when to do this.</span></span> <span data-ttu-id="93fc6-278">Poniższe przykłady kodu są dla klienta kodu JavaScript przy użyciu wygenerowany serwer proxy.</span><span class="sxs-lookup"><span data-stu-id="93fc6-278">The following code samples are for a JavaScript client using the generated proxy.</span></span>

- <span data-ttu-id="93fc6-279">Obsługa `connectionSlow` zdarzenie, aby wyświetlić komunikat, jak SignalR to znane problemy z połączeniem, zanim usługa zostanie wprowadzona do ponownego połączenia trybu.</span><span class="sxs-lookup"><span data-stu-id="93fc6-279">Handle the `connectionSlow` event to display a message as soon as SignalR is aware of connection problems, before it goes into reconnecting mode.</span></span>

    [!code-javascript[Main](handling-connection-lifetime-events/samples/sample2.js)]
- <span data-ttu-id="93fc6-280">Obsługa `reconnecting` zdarzenie, aby wyświetlić komunikat, gdy SignalR zna rozłączeniu i przechodzi do ponownego połączenia trybu.</span><span class="sxs-lookup"><span data-stu-id="93fc6-280">Handle the `reconnecting` event to display a message when SignalR is aware of a disconnection and is going into reconnecting mode.</span></span>

    [!code-javascript[Main](handling-connection-lifetime-events/samples/sample3.js)]
- <span data-ttu-id="93fc6-281">Obsługa `disconnected` zdarzenie, aby wyświetlić komunikat informujący o tym, gdy próba ponownego połączenia został przekroczony. W tym scenariuszu, jedynym sposobem, aby ponownie ustanowić połączenia z serwerem ponownie jest ponowne uruchomienie połączenia SignalR, wywołując `Start` metody, która utworzy nowy identyfikator połączenia.</span><span class="sxs-lookup"><span data-stu-id="93fc6-281">Handle the `disconnected` event to display a message when an attempt to reconnect has timed out. In this scenario, the only way to re-establish a connection with the server again is to restart the SignalR connection by calling the `Start` method, which will create a new connection ID.</span></span> <span data-ttu-id="93fc6-282">Poniższy przykład kodu używa flagi, aby zapewnić, generowaniu powiadomienia tylko po upływie ponownie nawiązującego połączenie limitu czasu, nie po normalne zakończenia połączenia SignalR, spowodowane przez wywołanie metody `Stop` metody.</span><span class="sxs-lookup"><span data-stu-id="93fc6-282">The following code sample uses a flag to make sure that you issue the notification only after a reconnecting timeout, not after a normal end to the SignalR connection caused by calling the `Stop` method.</span></span>

    [!code-javascript[Main](handling-connection-lifetime-events/samples/sample4.js)]

<a id="continuousreconnect"></a>

## <a name="how-to-continuously-reconnect"></a><span data-ttu-id="93fc6-283">Jak ponownie w sposób ciągły</span><span class="sxs-lookup"><span data-stu-id="93fc6-283">How to continuously reconnect</span></span>

<span data-ttu-id="93fc6-284">W niektórych aplikacjach można automatycznie ponownie ustanowić połączenia, po zostało utracone i ponowić próbę połączenia został przekroczony. Aby to zrobić, wywołując `Start` metody z Twojej `Closed` programu obsługi zdarzeń (`disconnected` programu obsługi zdarzeń na komputerach klienckich JavaScript).</span><span class="sxs-lookup"><span data-stu-id="93fc6-284">In some applications you might want to automatically re-establish a connection after it has been lost and the attempt to reconnect has timed out. To do that, you can call the `Start` method from your `Closed` event handler (`disconnected` event handler on JavaScript clients).</span></span> <span data-ttu-id="93fc6-285">Należy poczekać czasie przed wywołaniem `Start` aby zapobiec temu zbyt często kiedy serwer lub fizycznego połączenia są niedostępne.</span><span class="sxs-lookup"><span data-stu-id="93fc6-285">You might want to wait a period of time before calling `Start` in order to avoid doing this too frequently when the server or the physical connection are unavailable.</span></span> <span data-ttu-id="93fc6-286">Poniższy przykładowy kod dotyczy klienta języka JavaScript przy użyciu wygenerowany serwer proxy.</span><span class="sxs-lookup"><span data-stu-id="93fc6-286">The following code sample is for a JavaScript client using the generated proxy.</span></span>

[!code-javascript[Main](handling-connection-lifetime-events/samples/sample5.js)]

<span data-ttu-id="93fc6-287">Potencjalny problem pod uwagę w przypadku klientów mobilnych to, że prób ciągłe ponowne nawiązanie połączenia, gdy serwer lub fizyczne połączenie jest niedostępny, może spowodować zużycie baterii niepotrzebne.</span><span class="sxs-lookup"><span data-stu-id="93fc6-287">A potential problem to be aware of in mobile clients is that continuous reconnection attempts when the server or physical connection isn't available could cause unnecessary battery drain.</span></span>

<a id="disconnectclientfromserver"></a>

## <a name="how-to-disconnect-a-client-in-server-code"></a><span data-ttu-id="93fc6-288">Jak odłączyć klienta w kodzie serwera</span><span class="sxs-lookup"><span data-stu-id="93fc6-288">How to disconnect a client in server code</span></span>

<span data-ttu-id="93fc6-289">SignalR w wersji 2 nie ma wbudowanego serwera interfejsu API dla rozłączanie klientów.</span><span class="sxs-lookup"><span data-stu-id="93fc6-289">SignalR version 2 does not have a built-in server API for disconnecting clients.</span></span> <span data-ttu-id="93fc6-290">Istnieją [plany, aby dodać tę funkcję w przyszłości](https://github.com/SignalR/SignalR/issues/2101).</span><span class="sxs-lookup"><span data-stu-id="93fc6-290">There are [plans for adding this functionality in the future](https://github.com/SignalR/SignalR/issues/2101).</span></span> <span data-ttu-id="93fc6-291">W bieżącej wersji biblioteki SignalR Najprostszym sposobem, aby odłączyć klienta z serwera jest zaimplementować metodę rozłączenia na kliencie i wywoływanie tej metody z serwera.</span><span class="sxs-lookup"><span data-stu-id="93fc6-291">In the current SignalR release, the simplest way to disconnect a client from the server is to implement a disconnect method on the client and call that method from the server.</span></span> <span data-ttu-id="93fc6-292">Poniższy przykładowy kod przedstawia metodę rozłączenia dla klienta kodu JavaScript przy użyciu wygenerowany serwer proxy.</span><span class="sxs-lookup"><span data-stu-id="93fc6-292">The following code sample shows a disconnect method for a JavaScript client using the generated proxy.</span></span>

[!code-javascript[Main](handling-connection-lifetime-events/samples/sample6.js)]

> [!WARNING]
> <span data-ttu-id="93fc6-293">Zabezpieczenia — ta metoda rozłączanie klientów ani proponowane wbudowanego interfejsu API pozwala sprostać scenariusza zaatakowanych przez hakerów klientów z systemem złośliwego kodu, ponieważ klientów można się ponownie lub może spowodować usunięcie kodu zaatakowanych przez hakerów `stopClient` metody lub zmian Poznaj możliwości.</span><span class="sxs-lookup"><span data-stu-id="93fc6-293">Security - Neither this method for disconnecting clients nor the proposed built-in API will address the scenario of hacked clients that are running malicious code, since the clients could reconnect or the hacked code might remove the `stopClient` method or change what it does.</span></span> <span data-ttu-id="93fc6-294">Właściwym miejscem do implementowania stanowych ochrony (DOS) typu "odmowa usługi" jest nie w ramach lub warstwa serwera, ale raczej w infrastrukturze frontonu.</span><span class="sxs-lookup"><span data-stu-id="93fc6-294">The appropriate place to implement stateful denial-of-service (DOS) protection is not in the framework or the server layer, but rather in front-end infrastructure.</span></span>


<a id="detectingreasonfordisconnection"></a>
## <a name="detecting-the-reason-for-a-disconnection"></a><span data-ttu-id="93fc6-295">Wykrywanie Przyczyna zakończenia połączenia</span><span class="sxs-lookup"><span data-stu-id="93fc6-295">Detecting the reason for a disconnection</span></span>

<span data-ttu-id="93fc6-296">SignalR 2.1 dodaje przeciążenia do serwera `OnDisconnect` zdarzenie wskazujące, jeśli klient celowo odłączony, a nie z przekroczeniem limitu czasu. `StopCalled` Parametr ma wartość true, jeśli klient jawnie zamknął połączenie.</span><span class="sxs-lookup"><span data-stu-id="93fc6-296">SignalR 2.1 adds an overload to the server `OnDisconnect` event that indicates if the client deliberately disconnected rather than timing out. The `StopCalled` parameter is true if the client explicitly closed the connection.</span></span> <span data-ttu-id="93fc6-297">W języku JavaScript, jeśli błąd serwera prowadzone klienta, aby odłączyć, informacje o błędzie zostanie przekazany do klienta jako `$.connection.hub.lastError`.</span><span class="sxs-lookup"><span data-stu-id="93fc6-297">In JavaScript, if a server error led the client to disconnect, the error information will be passed to the client as `$.connection.hub.lastError`.</span></span>

**<span data-ttu-id="93fc6-298">C#Kod serwera: `stopCalled` parametru</span><span class="sxs-lookup"><span data-stu-id="93fc6-298">C# server code: `stopCalled` parameter</span></span>**

[!code-csharp[Main](handling-connection-lifetime-events/samples/sample7.cs?highlight=1,3)]

**<span data-ttu-id="93fc6-299">Kod klienta JavaScript: uzyskiwanie dostępu do `lastError` w `disconnect` zdarzeń.</span><span class="sxs-lookup"><span data-stu-id="93fc6-299">JavaScript client code: accessing `lastError` in the `disconnect` event.</span></span>**

[!code-javascript[Main](handling-connection-lifetime-events/samples/sample8.js?highlight=2-3)]
