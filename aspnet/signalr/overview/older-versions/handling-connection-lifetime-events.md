---
uid: signalr/overview/older-versions/handling-connection-lifetime-events
title: Zrozumienie i obsługa zdarzeń okresu istnienia połączenia w sygnale 1. x | Microsoft Docs
author: bradygaster
description: W tym artykule opisano sposób korzystania z zdarzeń udostępnianych przez interfejs API centrów.
ms.author: bradyg
ms.date: 06/05/2013
ms.assetid: e608e263-264d-448b-b0eb-6eeb77713b22
msc.legacyurl: /signalr/overview/older-versions/handling-connection-lifetime-events
msc.type: authoredcontent
ms.openlocfilehash: 2fb671e730a1d41c07b350bf1d64ac1d0b1be55c
ms.sourcegitcommit: e7e91932a6e91a63e2e46417626f39d6b244a3ab
ms.translationtype: MT
ms.contentlocale: pl-PL
ms.lasthandoff: 03/06/2020
ms.locfileid: "78536905"
---
# <a name="understanding-and-handling-connection-lifetime-events-in-signalr-1x"></a><span data-ttu-id="98ffc-103">Zrozumienie i obsługa zdarzeń okresu istnienia połączenia w sygnale 1. x</span><span class="sxs-lookup"><span data-stu-id="98ffc-103">Understanding and Handling Connection Lifetime Events in SignalR 1.x</span></span>

<span data-ttu-id="98ffc-104">[Fletcher Patryk](https://github.com/pfletcher), [Tomasz Dykstra](https://github.com/tdykstra)</span><span class="sxs-lookup"><span data-stu-id="98ffc-104">by [Patrick Fletcher](https://github.com/pfletcher), [Tom Dykstra](https://github.com/tdykstra)</span></span>

[!INCLUDE [Consider ASP.NET Core SignalR](~/includes/signalr/signalr-version-disambiguation.md)]

> <span data-ttu-id="98ffc-105">Ten artykuł zawiera omówienie zdarzeń związanych z połączeniem, ponownym połączeniem i rozłączaniem, które można obsłużyć, oraz ustawień limitu czasu i utrzymywania aktywności, które można skonfigurować.</span><span class="sxs-lookup"><span data-stu-id="98ffc-105">This article provides an overview of the SignalR connection, reconnection, and disconnection events that you can handle, and timeout and keepalive settings that you can configure.</span></span>
> 
> <span data-ttu-id="98ffc-106">W artykule założono, że masz już pewną wiedzę o zdarzeniach dotyczących czasu istnienia sygnalizującego i połączenia.</span><span class="sxs-lookup"><span data-stu-id="98ffc-106">The article assumes you already have some knowledge of SignalR and connection lifetime events.</span></span> <span data-ttu-id="98ffc-107">Aby zapoznać się z wprowadzeniem do sygnalizacji, zobacz [sygnalizacja — Omówienie — wprowadzenie](index.md).</span><span class="sxs-lookup"><span data-stu-id="98ffc-107">For an introduction to SignalR, see [SignalR - Overview - Getting Started](index.md).</span></span> <span data-ttu-id="98ffc-108">Aby uzyskać listę zdarzeń okresu istnienia połączenia, zobacz następujące zasoby:</span><span class="sxs-lookup"><span data-stu-id="98ffc-108">For lists of connection lifetime events, see the following resources:</span></span>
> 
> - [<span data-ttu-id="98ffc-109">Jak obsłużyć zdarzenia okresu istnienia połączenia w klasie centrów</span><span class="sxs-lookup"><span data-stu-id="98ffc-109">How to handle connection lifetime events in the Hub class</span></span>](index.md)
> - [<span data-ttu-id="98ffc-110">Jak obsługiwać zdarzenia okresu istnienia połączenia w klientach JavaScript</span><span class="sxs-lookup"><span data-stu-id="98ffc-110">How to handle connection lifetime events in JavaScript clients</span></span>](index.md)
> - [<span data-ttu-id="98ffc-111">Jak obsługiwać zdarzenia okresu istnienia połączenia w klientach platformy .NET</span><span class="sxs-lookup"><span data-stu-id="98ffc-111">How to handle connection lifetime events in .NET clients</span></span>](index.md)

## <a name="overview"></a><span data-ttu-id="98ffc-112">Omówienie</span><span class="sxs-lookup"><span data-stu-id="98ffc-112">Overview</span></span>

<span data-ttu-id="98ffc-113">Ten artykuł zawiera następujące sekcje:</span><span class="sxs-lookup"><span data-stu-id="98ffc-113">This article contains the following sections:</span></span>

- [<span data-ttu-id="98ffc-114">Terminologia i scenariusze okresu istnienia połączenia</span><span class="sxs-lookup"><span data-stu-id="98ffc-114">Connection lifetime terminology and scenarios</span></span>](#terminology)

    - [<span data-ttu-id="98ffc-115">Połączenia sygnalizujące, połączenia transportowe i połączenia fizyczne</span><span class="sxs-lookup"><span data-stu-id="98ffc-115">SignalR connections, transport connections, and physical connections</span></span>](#signalrvstransport)
    - [<span data-ttu-id="98ffc-116">Scenariusze związane z transportem transportu</span><span class="sxs-lookup"><span data-stu-id="98ffc-116">Transport disconnection scenarios</span></span>](#transportdisconnect)
    - [<span data-ttu-id="98ffc-117">Scenariusze rozłączenia klientów</span><span class="sxs-lookup"><span data-stu-id="98ffc-117">Client disconnection scenarios</span></span>](#clientdisconnect)
    - [<span data-ttu-id="98ffc-118">Scenariusze odłączenia serwera</span><span class="sxs-lookup"><span data-stu-id="98ffc-118">Server disconnection scenarios</span></span>](#serverdisconnect)
- [<span data-ttu-id="98ffc-119">Ustawienia limitu czasu i utrzymywania aktywności</span><span class="sxs-lookup"><span data-stu-id="98ffc-119">Timeout and keepalive settings</span></span>](#timeoutkeepalive)

    - [<span data-ttu-id="98ffc-120">Parametru</span><span class="sxs-lookup"><span data-stu-id="98ffc-120">ConnectionTimeout</span></span>](#connectiontimeout)
    - [<span data-ttu-id="98ffc-121">DisconnectTimeout</span><span class="sxs-lookup"><span data-stu-id="98ffc-121">DisconnectTimeout</span></span>](#disconnecttimeout)
    - [<span data-ttu-id="98ffc-122">Utrzymywani</span><span class="sxs-lookup"><span data-stu-id="98ffc-122">KeepAlive</span></span>](#keepalive)
    - [<span data-ttu-id="98ffc-123">Jak zmienić limit czasu i ustawienia utrzymywania aktywności</span><span class="sxs-lookup"><span data-stu-id="98ffc-123">How to change timeout and keepalive settings</span></span>](#changetimeout)
- [<span data-ttu-id="98ffc-124">Jak powiadomić użytkownika o rozwiązaniu</span><span class="sxs-lookup"><span data-stu-id="98ffc-124">How to notify the user about disconnections</span></span>](#notifydisconnect)
- [<span data-ttu-id="98ffc-125">Jak ciągle ponownie nawiązać połączenie</span><span class="sxs-lookup"><span data-stu-id="98ffc-125">How to continuously reconnect</span></span>](#continuousreconnect)
- [<span data-ttu-id="98ffc-126">Jak rozłączyć klienta w kodzie serwera</span><span class="sxs-lookup"><span data-stu-id="98ffc-126">How to disconnect a client in server code</span></span>](#disconnectclientfromserver)

<span data-ttu-id="98ffc-127">Łącza do tematów dotyczących odwołań do interfejsów API znajdują się w wersji programu .NET 4,5 interfejsu API.</span><span class="sxs-lookup"><span data-stu-id="98ffc-127">Links to API Reference topics are to the .NET 4.5 version of the API.</span></span> <span data-ttu-id="98ffc-128">Jeśli używasz programu .NET 4, zobacz [temat wersja interfejsu API w wersji .NET 4](https://msdn.microsoft.com/library/jj891075(v=vs.100).aspx).</span><span class="sxs-lookup"><span data-stu-id="98ffc-128">If you're using .NET 4, see [the .NET 4 version of the API topics](https://msdn.microsoft.com/library/jj891075(v=vs.100).aspx).</span></span>

<a id="terminology"></a>

## <a name="connection-lifetime-terminology-and-scenarios"></a><span data-ttu-id="98ffc-129">Terminologia i scenariusze okresu istnienia połączenia</span><span class="sxs-lookup"><span data-stu-id="98ffc-129">Connection lifetime terminology and scenarios</span></span>

<span data-ttu-id="98ffc-130">Program obsługi zdarzeń `OnReconnected` w centrum sygnałów można wykonać bezpośrednio po `OnConnected`, ale nie po `OnDisconnected` dla danego klienta.</span><span class="sxs-lookup"><span data-stu-id="98ffc-130">The `OnReconnected` event handler in a SignalR Hub can execute directly after `OnConnected` but not after `OnDisconnected` for a given client.</span></span> <span data-ttu-id="98ffc-131">Przyczyną może być ponowne połączenie bez rozłączenia, ponieważ istnieje kilka sposobów, w których słowo "Connection" jest używane w programie sygnalizującym.</span><span class="sxs-lookup"><span data-stu-id="98ffc-131">The reason you can have a reconnection without a disconnection is that there are several ways in which the word "connection" is used in SignalR.</span></span>

<a id="signalrvstransport"></a>

### <a name="signalr-connections-transport-connections-and-physical-connections"></a><span data-ttu-id="98ffc-132">Połączenia sygnalizujące, połączenia transportowe i połączenia fizyczne</span><span class="sxs-lookup"><span data-stu-id="98ffc-132">SignalR connections, transport connections, and physical connections</span></span>

<span data-ttu-id="98ffc-133">Ten artykuł rozróżni się między *połączeniami sygnalizującymi*, *połączeniami transportowymi*i *połączeniami fizycznymi*:</span><span class="sxs-lookup"><span data-stu-id="98ffc-133">This article will differentiate between *SignalR connections*, *transport connections*, and *physical connections*:</span></span>

- <span data-ttu-id="98ffc-134">**Połączenie sygnalizujące** odnosi się do logicznej relacji między klientem a adresem URL serwera, obsługiwane przez interfejs API sygnalizujące i jednoznacznie identyfikowane przez identyfikator połączenia.</span><span class="sxs-lookup"><span data-stu-id="98ffc-134">**SignalR connection** refers to a logical relationship between a client and a server URL, maintained by the SignalR API and uniquely identified by a connection ID.</span></span> <span data-ttu-id="98ffc-135">Dane dotyczące tej relacji są obsługiwane przez program sygnalizujący i są używane do nawiązywania połączenia transportowego.</span><span class="sxs-lookup"><span data-stu-id="98ffc-135">The data about this relationship is maintained by SignalR and is used to establish a transport connection.</span></span> <span data-ttu-id="98ffc-136">Relacje kończą się i sygnalizujący usuwa dane, gdy klient wywołuje metodę `Stop` lub limit czasu zostanie osiągnięty podczas próby ponownego nawiązania połączenia z utraconym transportem przez sygnał.</span><span class="sxs-lookup"><span data-stu-id="98ffc-136">The relationship ends and SignalR disposes of the data when the client calls the `Stop` method or a timeout limit is reached while SignalR is attempting to re-establish a lost transport connection.</span></span>
- <span data-ttu-id="98ffc-137">**Połączenie transportowe** odwołuje się do logicznej relacji między klientem a serwerem, który jest obsługiwany przez jeden z czterech interfejsów API transportu: WebSockets, zdarzeń wysyłanych przez serwer, ramki nieograniczonej lub długiej sondowania.</span><span class="sxs-lookup"><span data-stu-id="98ffc-137">**Transport connection** refers to a logical relationship between a client and a server, maintained by one of the four transport APIs: WebSockets, server-sent events, forever frame, or long polling.</span></span> <span data-ttu-id="98ffc-138">Program sygnalizujący używa interfejsu API transportu do utworzenia połączenia transportowego, a interfejs API transportu zależy od istnienia fizycznego połączenia sieciowego w celu utworzenia połączenia transportowego.</span><span class="sxs-lookup"><span data-stu-id="98ffc-138">SignalR uses the transport API to create a transport connection, and the transport API depends on the existence of a physical network connection to create the transport connection.</span></span> <span data-ttu-id="98ffc-139">Połączenie transportowe kończy się, gdy sygnał kończy działanie lub gdy interfejs API transportu wykryje, że połączenie fizyczne zostało przerwane.</span><span class="sxs-lookup"><span data-stu-id="98ffc-139">The transport connection ends when SignalR terminates it or when the transport API detects that the physical connection is broken.</span></span>
- <span data-ttu-id="98ffc-140">**Połączenie fizyczne** dotyczy linków sieci fizycznej — przewodów, sygnałów bezprzewodowych, routerów itp., które ułatwiają komunikację między komputerem klienckim a serwerem.</span><span class="sxs-lookup"><span data-stu-id="98ffc-140">**Physical connection** refers to the physical network links -- wires, wireless signals, routers, etc. -- that facilitate communication between a client computer and a server computer.</span></span> <span data-ttu-id="98ffc-141">Połączenie fizyczne musi być obecne, aby można było nawiązać połączenie transportowe, a połączenie transportowe zostało nawiązane w celu nawiązania połączenia z sygnałem.</span><span class="sxs-lookup"><span data-stu-id="98ffc-141">The physical connection must be present in order to establish a transport connection, and a transport connection must be established in order to establish a SignalR connection.</span></span> <span data-ttu-id="98ffc-142">Jednak przerwanie połączenia fizycznego nie zawsze powoduje natychmiastowe zakończenie połączenia transportowego lub połączenia sygnalizującego, jak zostało to opisane w dalszej części tego tematu.</span><span class="sxs-lookup"><span data-stu-id="98ffc-142">However, breaking the physical connection doesn't always immediately end the transport connection or the SignalR connection, as will be explained later in this topic.</span></span>

<span data-ttu-id="98ffc-143">Na poniższym diagramie połączenie sygnalizujące jest reprezentowane przez interfejs API centrów i warstwę sygnałów interfejsu API PersistentConnection, połączenie transportowe jest reprezentowane przez warstwę Transports, a połączenie fizyczne jest reprezentowane przez linie między serwerem. i klienci programu.</span><span class="sxs-lookup"><span data-stu-id="98ffc-143">In the following diagram, the SignalR connection is represented by the Hubs API and PersistentConnection API SignalR layer, the transport connection is represented by the Transports layer, and the physical connection is represented by the lines between the server and the clients.</span></span>

![Diagram architektury sygnałów](handling-connection-lifetime-events/_static/image1.png)

<span data-ttu-id="98ffc-145">Po wywołaniu metody `Start` w kliencie sygnalizującym jest dostarczany kod klienta sygnalizującego ze wszystkimi informacjami, które są potrzebne w celu nawiązania połączenia fizycznego z serwerem.</span><span class="sxs-lookup"><span data-stu-id="98ffc-145">When you call the `Start` method in a SignalR client, you are providing SignalR client code with all the information it needs in order to establish a physical connection to a server.</span></span> <span data-ttu-id="98ffc-146">Kod klienta sygnalizujący używa tych informacji do utworzenia żądania HTTP i ustanowienia połączenia fizycznego korzystającego z jednej z czterech metod transportu.</span><span class="sxs-lookup"><span data-stu-id="98ffc-146">SignalR client code uses this information to make an HTTP request and establish a physical connection that uses one of the four transport methods.</span></span> <span data-ttu-id="98ffc-147">Jeśli połączenie transportowe nie powiedzie się lub serwer ulegnie awarii, połączenie sygnalizujące nie zostanie natychmiast odrzucone, ponieważ klient nadal ma informacje potrzebne do automatycznego ponownego ustanowienia nowego połączenia transportowego z tym samym adresem URL sygnalizującego.</span><span class="sxs-lookup"><span data-stu-id="98ffc-147">If the transport connection fails or the server fails, the SignalR connection doesn't go away immediately because the client still has the information it needs to automatically re-establish a new transport connection to the same SignalR URL.</span></span> <span data-ttu-id="98ffc-148">W tym scenariuszu nie jest uwzględniana interwencja z aplikacji użytkownika, a gdy kod klienta sygnalizującego ustanawia nowe połączenie transportowe, nie zostanie uruchomione nowe połączenie sygnalizujące.</span><span class="sxs-lookup"><span data-stu-id="98ffc-148">In this scenario, no intervention from the user application is involved, and when the SignalR client code establishes a new transport connection, it does not start a new SignalR connection.</span></span> <span data-ttu-id="98ffc-149">Ciągłość połączenia sygnalizującego jest odzwierciedlona w tym fakcie, że identyfikator połączenia, który jest tworzony podczas wywoływania metody `Start`, nie zmienia się.</span><span class="sxs-lookup"><span data-stu-id="98ffc-149">The continuity of the SignalR connection is reflected in the fact that the connection ID, which is created when you call the `Start` method, does not change.</span></span>

<span data-ttu-id="98ffc-150">Procedura obsługi zdarzeń `OnReconnected` w centrum jest wykonywana po ponownym nawiązaniu połączenia transportowego po jego utracie.</span><span class="sxs-lookup"><span data-stu-id="98ffc-150">The `OnReconnected` event handler on the Hub executes when a transport connection is automatically re-established after having been lost.</span></span> <span data-ttu-id="98ffc-151">Procedura obsługi zdarzeń `OnDisconnected` jest wykonywana po zakończeniu połączenia sygnalizującego.</span><span class="sxs-lookup"><span data-stu-id="98ffc-151">The `OnDisconnected` event handler executes at the end of a SignalR connection.</span></span> <span data-ttu-id="98ffc-152">Połączenie sygnalizujące może kończyć się jednym z następujących sposobów:</span><span class="sxs-lookup"><span data-stu-id="98ffc-152">A SignalR connection can end in any of the following ways:</span></span>

- <span data-ttu-id="98ffc-153">Jeśli klient wywoła metodę `Stop`, do serwera zostanie wysłany komunikat zatrzymania, a zarówno klient, jak i serwer kończą połączenie sygnalizujące.</span><span class="sxs-lookup"><span data-stu-id="98ffc-153">If the client calls the `Stop` method, a stop message is sent to the server, and both client and server end the SignalR connection immediately.</span></span>
- <span data-ttu-id="98ffc-154">Po utracie połączenia między klientem a serwerem klient próbuje ponownie nawiązać połączenie, a serwer czeka na ponowne nawiązanie połączenia przez klienta.</span><span class="sxs-lookup"><span data-stu-id="98ffc-154">After connectivity between client and server is lost, the client tries to reconnect and the server waits for the client to reconnect.</span></span> <span data-ttu-id="98ffc-155">Jeśli próba ponownego połączenia nie powiedzie się i upłynie limit czasu rozłączenia, zarówno klient, jak i serwer zakończą połączenie sygnalizujące.</span><span class="sxs-lookup"><span data-stu-id="98ffc-155">If the attempts to reconnect are unsuccessful and the disconnect timeout period ends, both client and server end the SignalR connection.</span></span> <span data-ttu-id="98ffc-156">Klient przestanie próbować ponownie nawiązać połączenie, a serwer usuwa jego reprezentację połączenia sygnalizującego.</span><span class="sxs-lookup"><span data-stu-id="98ffc-156">The client stops trying to reconnect, and the server disposes of its representation of the SignalR connection.</span></span>
- <span data-ttu-id="98ffc-157">Jeśli klient przestanie działać bez możliwości wywołania metody `Stop`, serwer czeka, aż klient ponownie nawiąże połączenie, a następnie zakończy połączenie sygnalizujące po upływie limitu czasu rozłączenia.</span><span class="sxs-lookup"><span data-stu-id="98ffc-157">If the client stops running without having a chance to call the `Stop` method, the server waits for the client to reconnect, and then ends the SignalR connection after the disconnect timeout period.</span></span>
- <span data-ttu-id="98ffc-158">Jeśli serwer przestanie działać, klient próbuje ponownie nawiązać połączenie (ponownie utworzyć połączenie transportowe), a następnie zakończy połączenie sygnalizujące po upływie limitu czasu rozłączenia.</span><span class="sxs-lookup"><span data-stu-id="98ffc-158">If the server stops running, the client tries to reconnect (re-create the transport connection), and then ends the SignalR connection after the disconnect timeout period.</span></span>

<span data-ttu-id="98ffc-159">Gdy nie występują problemy z połączeniem, a aplikacja użytkownika kończy połączenie sygnalizujące, wywołując metodę `Stop`, połączenie sygnalizujące i rozpoczęcie i zakończenie połączenia transportowego.</span><span class="sxs-lookup"><span data-stu-id="98ffc-159">When there are no connection problems, and the user application ends the SignalR connection by calling the `Stop` method, the SignalR connection and the transport connection begin and end at about the same time.</span></span> <span data-ttu-id="98ffc-160">W poniższych sekcjach opisano bardziej szczegółowo inne scenariusze.</span><span class="sxs-lookup"><span data-stu-id="98ffc-160">The following sections describe in more detail the other scenarios.</span></span>

<a id="transportdisconnect"></a>

### <a name="transport-disconnection-scenarios"></a><span data-ttu-id="98ffc-161">Scenariusze związane z transportem transportu</span><span class="sxs-lookup"><span data-stu-id="98ffc-161">Transport disconnection scenarios</span></span>

<span data-ttu-id="98ffc-162">Połączenia fizyczne mogą być wolne lub mogą występować przerwy w łączności.</span><span class="sxs-lookup"><span data-stu-id="98ffc-162">Physical connections might be slow or there might be interruptions in connectivity.</span></span> <span data-ttu-id="98ffc-163">W zależności od czynników, takich jak długość przerwania, połączenie transportowe może zostać porzucone.</span><span class="sxs-lookup"><span data-stu-id="98ffc-163">Depending on factors such as the length of the interruption, the transport connection might be dropped.</span></span> <span data-ttu-id="98ffc-164">Program sygnalizujący próbę ponownego nawiązania połączenia transportowego.</span><span class="sxs-lookup"><span data-stu-id="98ffc-164">SignalR then tries to re-establish the transport connection.</span></span> <span data-ttu-id="98ffc-165">Czasami interfejs API połączenia transportowego wykrywa przerwanie i opuszcza połączenie transportowe, a sygnalizujące natychmiast, że połączenie zostało utracone.</span><span class="sxs-lookup"><span data-stu-id="98ffc-165">Sometimes the transport connection API detects the interruption and drops the transport connection, and SignalR finds out immediately that the connection is lost.</span></span> <span data-ttu-id="98ffc-166">W innych scenariuszach ani interfejs API połączenia transportowego ani sygnał nie są świadome natychmiast, gdy połączenie zostało utracone.</span><span class="sxs-lookup"><span data-stu-id="98ffc-166">In other scenarios, neither the transport connection API nor SignalR becomes aware immediately that connectivity has been lost.</span></span> <span data-ttu-id="98ffc-167">W przypadku wszystkich transportów z wyjątkiem długiego sondowania klient sygnalizujący używa funkcji o *nazwie* in, aby sprawdzić, czy nie jest możliwe wykrycie łączności przez interfejs API transportu.</span><span class="sxs-lookup"><span data-stu-id="98ffc-167">For all transports except long polling, the SignalR client uses a function called *keepalive* to check for loss of connectivity that the transport API is unable to detect.</span></span> <span data-ttu-id="98ffc-168">Aby uzyskać informacje na temat długich połączeń sondowania, zobacz [Ustawienia limitu czasu i utrzymywania aktywności](#timeoutkeepalive) w dalszej części tego tematu.</span><span class="sxs-lookup"><span data-stu-id="98ffc-168">For information about long polling connections, see [Timeout and keepalive settings](#timeoutkeepalive) later in this topic.</span></span>

<span data-ttu-id="98ffc-169">Gdy połączenie jest nieaktywne, okresowo wysyła do klienta pakiet utrzymywania aktywności.</span><span class="sxs-lookup"><span data-stu-id="98ffc-169">When a connection is inactive, periodically the server sends a keepalive packet to the client.</span></span> <span data-ttu-id="98ffc-170">Od daty zapisania tego artykułu domyślna częstotliwość wynosi co 10 sekund.</span><span class="sxs-lookup"><span data-stu-id="98ffc-170">As of the date this article is being written, the default frequency is every 10 seconds.</span></span> <span data-ttu-id="98ffc-171">Przez nasłuchiwanie tych pakietów klienci mogą stwierdzić, czy występuje problem z połączeniem.</span><span class="sxs-lookup"><span data-stu-id="98ffc-171">By listening for these packets, clients can tell if there is a connection problem.</span></span> <span data-ttu-id="98ffc-172">Jeśli pakiet utrzymywania aktywności nie zostanie odebrany w oczekiwany sposób, po krótkim czasie klient zakłada, że wystąpiły problemy z połączeniem, takie jak spowolnienie lub przerwy.</span><span class="sxs-lookup"><span data-stu-id="98ffc-172">If a keepalive packet is not received when expected, after a short time the client assumes that there are connection problems such as slowness or interruptions.</span></span> <span data-ttu-id="98ffc-173">Jeśli w dalszym ciągu nie otrzymasz czasu utrzymywania, klient zakłada, że połączenie zostało porzucone i rozpocznie próbę ponownego nawiązania połączenia.</span><span class="sxs-lookup"><span data-stu-id="98ffc-173">If the keepalive is still not received after a longer time, the client assumes that the connection has been dropped, and it begins trying to reconnect.</span></span>

<span data-ttu-id="98ffc-174">Na poniższym diagramie przedstawiono zdarzenia klienta i serwera, które zostały zgłoszone w typowym scenariuszu w przypadku problemów z połączeniem fizycznym, które nie są rozpoznawane bezpośrednio przez interfejs API transportu.</span><span class="sxs-lookup"><span data-stu-id="98ffc-174">The following diagram illustrates the client and server events that are raised in a typical scenario when there are problems with the physical connection that aren't immediately recognized by the transport API.</span></span> <span data-ttu-id="98ffc-175">Diagram ma zastosowanie do następujących sytuacji:</span><span class="sxs-lookup"><span data-stu-id="98ffc-175">The diagram applies to the following circumstances:</span></span>

- <span data-ttu-id="98ffc-176">Transport to obiekty WebSockets, nieskończone ramki lub zdarzenia wysyłane przez serwer.</span><span class="sxs-lookup"><span data-stu-id="98ffc-176">The transport is WebSockets, forever frame, or server-sent events.</span></span>
- <span data-ttu-id="98ffc-177">Istnieją różne okresy przerwy w połączeniu z siecią fizyczną.</span><span class="sxs-lookup"><span data-stu-id="98ffc-177">There are varying periods of interruption in the physical network connection.</span></span>
- <span data-ttu-id="98ffc-178">Interfejs API transportu nie jest świadomy przerw w działaniu, więc usługa sygnalizująca jest zależna od funkcjonalności w celu ich wykrycia.</span><span class="sxs-lookup"><span data-stu-id="98ffc-178">The transport API does not become aware of the interruptions, so SignalR relies on the keepalive functionality to detect them.</span></span>

![Połączenia transportowe](handling-connection-lifetime-events/_static/image2.png)

<span data-ttu-id="98ffc-180">Jeśli klient przejdzie w tryb ponownego połączenia, ale nie może nawiązać połączenia transportowego w ramach limitu czasu rozłączenia, serwer przerywa połączenie sygnalizujące.</span><span class="sxs-lookup"><span data-stu-id="98ffc-180">If the client goes into reconnecting mode but can't establish a transport connection within the disconnect timeout limit, the server terminates the SignalR connection.</span></span> <span data-ttu-id="98ffc-181">W takim przypadku serwer wykonuje metodę `OnDisconnected` centrum i kolejkuje komunikat rozłączenia w celu wysłania go do klienta na wypadek, gdyby klient zarządzał w celu późniejszego nawiązania połączenia.</span><span class="sxs-lookup"><span data-stu-id="98ffc-181">When that happens, the server executes the Hub's `OnDisconnected` method and queues up a disconnect message to send to the client in case the client manages to connect later.</span></span> <span data-ttu-id="98ffc-182">Jeśli klient ponownie nawiązuje połączenie, odbiera polecenie Disconnect i wywołuje metodę `Stop`.</span><span class="sxs-lookup"><span data-stu-id="98ffc-182">If the client then does reconnect, it receives the disconnect command and calls the `Stop` method.</span></span> <span data-ttu-id="98ffc-183">W tym scenariuszu `OnReconnected` nie jest wykonywane, gdy klient ponownie nawiązuje połączenie, a `OnDisconnected` nie jest wykonywane, gdy klient wywoła `Stop`.</span><span class="sxs-lookup"><span data-stu-id="98ffc-183">In this scenario, `OnReconnected` is not executed when the client reconnects, and `OnDisconnected` is not executed when the client calls `Stop`.</span></span> <span data-ttu-id="98ffc-184">Na poniższym diagramie przedstawiono ten scenariusz.</span><span class="sxs-lookup"><span data-stu-id="98ffc-184">The following diagram illustrates this scenario.</span></span>

![Zakłócenia transportu — limit czasu serwera](handling-connection-lifetime-events/_static/image3.png)

<span data-ttu-id="98ffc-186">Zdarzenia okresu istnienia połączenia sygnalizującego, które mogą zostać zgłoszone na kliencie, są następujące:</span><span class="sxs-lookup"><span data-stu-id="98ffc-186">The SignalR connection lifetime events that may be raised on the client are the following:</span></span>

- <span data-ttu-id="98ffc-187">`ConnectionSlow` zdarzenie klienta.</span><span class="sxs-lookup"><span data-stu-id="98ffc-187">`ConnectionSlow` client event.</span></span>

    <span data-ttu-id="98ffc-188">Uruchamiany, gdy otrzymano wstępną część okresu limitu czasu utrzymywania aktywności od momentu odebrania ostatniej wiadomości lub polecenia ping o utrzymywaniu aktywności.</span><span class="sxs-lookup"><span data-stu-id="98ffc-188">Raised when a preset proportion of the keepalive timeout period has passed since the last message or keepalive ping was received.</span></span> <span data-ttu-id="98ffc-189">Domyślny okres ostrzegawczy limitu czasu utrzymywania aktywności wynosi 2/3.</span><span class="sxs-lookup"><span data-stu-id="98ffc-189">The default keepalive timeout warning period is 2/3 of the keepalive timeout.</span></span> <span data-ttu-id="98ffc-190">Limit czasu utrzymywania aktywności wynosi 20 sekund, więc ostrzeżenie występuje przez około 13 sekund.</span><span class="sxs-lookup"><span data-stu-id="98ffc-190">The keepalive timeout is 20 seconds, so the warning occurs at about 13 seconds.</span></span>

    <span data-ttu-id="98ffc-191">Domyślnie serwer wysyła polecenia ping o utrzymywanie aktywności co 10 sekund, a klient sprawdza, czy nie działa polecenie ping o utrzymywanie aktywności co 2 sekundy (jedna trzecia różnica między wartością limitu czasu utrzymywania aktywności a wartością ostrzegawczą limitu czasu utrzymywania aktywności).</span><span class="sxs-lookup"><span data-stu-id="98ffc-191">By default, the server sends keepalive pings every 10 seconds, and the client checks for keepalive pings about every 2 seconds (one third of the difference between the keepalive timeout value and the keepalive timeout warning value).</span></span>

    <span data-ttu-id="98ffc-192">Jeśli interfejs API transportu zostanie poinformowany o rozwiązaniu, sygnalizujący może zostać poinformowany o rozwiązaniu, zanim upłynie okres ostrzegawczy limitu czasu utrzymywania aktywności.</span><span class="sxs-lookup"><span data-stu-id="98ffc-192">If the transport API becomes aware of a disconnection, SignalR might be informed of the disconnection before the keepalive timeout warning period passes.</span></span> <span data-ttu-id="98ffc-193">W takim przypadku zdarzenie `ConnectionSlow` nie zostanie wywołane, a program sygnalizujący przechodzi bezpośrednio do zdarzenia `Reconnecting`.</span><span class="sxs-lookup"><span data-stu-id="98ffc-193">In that case, the `ConnectionSlow` event would not be raised, and SignalR would go directly to the `Reconnecting` event.</span></span>
- <span data-ttu-id="98ffc-194">`Reconnecting` zdarzenie klienta.</span><span class="sxs-lookup"><span data-stu-id="98ffc-194">`Reconnecting` client event.</span></span>

    <span data-ttu-id="98ffc-195">Wywoływane, gdy (a) interfejs API transportu wykryje, że połączenie zostało utracone lub (b) upłynął limit czasu utrzymywania aktywności od momentu odebrania ostatniej wiadomości lub polecenia ping o utrzymywaniu aktywności.</span><span class="sxs-lookup"><span data-stu-id="98ffc-195">Raised when (a) the transport API detects that the connection is lost, or (b) the keepalive timeout period has passed since the last message or keepalive ping was received.</span></span> <span data-ttu-id="98ffc-196">Kod klienta sygnalizującego rozpoczyna próbę ponownego nawiązania połączenia.</span><span class="sxs-lookup"><span data-stu-id="98ffc-196">The SignalR client code begins trying to reconnect.</span></span> <span data-ttu-id="98ffc-197">To zdarzenie można obsłużyć, jeśli aplikacja ma podejmować pewne działania po utracie połączenia transportowego.</span><span class="sxs-lookup"><span data-stu-id="98ffc-197">You can handle this event if you want your application to take some action when a transport connection is lost.</span></span> <span data-ttu-id="98ffc-198">Domyślny limit czasu utrzymywania aktywności wynosi obecnie 20 sekund.</span><span class="sxs-lookup"><span data-stu-id="98ffc-198">The default keepalive timeout period is currently 20 seconds.</span></span>

    <span data-ttu-id="98ffc-199">Jeśli kod klienta próbuje wywołać metodę Hub, podczas gdy sygnalizujący jest w trybie ponownego łączenia, sygnalizujący spróbuje wysłać polecenie.</span><span class="sxs-lookup"><span data-stu-id="98ffc-199">If your client code tries to call a Hub method while SignalR is in reconnecting mode, SignalR will try to send the command.</span></span> <span data-ttu-id="98ffc-200">W większości przypadków takie próby zakończą się niepowodzeniem, ale w pewnych okolicznościach mogą się one kończyć pomyślnie.</span><span class="sxs-lookup"><span data-stu-id="98ffc-200">Most of the time, such attempts will fail, but in some circumstances they might succeed.</span></span> <span data-ttu-id="98ffc-201">Dla zdarzeń wysyłanych przez serwer, ramki bez ograniczeń i długotrwałe transporty, sygnalizujący używa dwóch kanałów komunikacyjnych, które są używane przez klienta do wysyłania komunikatów i tych, które są używane do odbierania komunikatów.</span><span class="sxs-lookup"><span data-stu-id="98ffc-201">For the server-sent events, forever frame, and long polling transports, SignalR uses two communication channels, one that the client uses to send messages and one that it uses to receive messages.</span></span> <span data-ttu-id="98ffc-202">Kanał używany do odbioru jest trwale otwarty i jest to ten, który jest zamknięty po przerwaniu połączenia fizycznego.</span><span class="sxs-lookup"><span data-stu-id="98ffc-202">The channel used for receiving is the permanently open one, and that's the one that is closed when the physical connection is interrupted.</span></span> <span data-ttu-id="98ffc-203">Kanał używany do wysyłania pozostaje dostępny, więc jeśli zostanie przywrócona łączność fizyczna, wywołanie metody z klienta do serwera może zakończyć się pomyślnie przed ponownym ustanowieniem kanału odbiorczego.</span><span class="sxs-lookup"><span data-stu-id="98ffc-203">The channel used for sending remains available, so if physical connectivity is restored, a method call from client to server might be successful before the receive channel is re-established.</span></span> <span data-ttu-id="98ffc-204">Wartość zwracana nie zostanie odebrana, dopóki nie zostanie ponownie otwarty kanał używany do odbierania.</span><span class="sxs-lookup"><span data-stu-id="98ffc-204">The return value would not be received until SignalR re-opens the channel used for receiving.</span></span>
- <span data-ttu-id="98ffc-205">`Reconnected` zdarzenie klienta.</span><span class="sxs-lookup"><span data-stu-id="98ffc-205">`Reconnected` client event.</span></span>

    <span data-ttu-id="98ffc-206">Uruchamiany po ponownej nawiązaniu połączenia transportowego.</span><span class="sxs-lookup"><span data-stu-id="98ffc-206">Raised when the transport connection is reestablished.</span></span> <span data-ttu-id="98ffc-207">Program obsługi zdarzeń `OnReconnected` w centrum wykonuje.</span><span class="sxs-lookup"><span data-stu-id="98ffc-207">The `OnReconnected` event handler in the Hub executes.</span></span>
- <span data-ttu-id="98ffc-208">`Closed` zdarzenie klienta (`disconnected` zdarzenia w języku JavaScript).</span><span class="sxs-lookup"><span data-stu-id="98ffc-208">`Closed` client event (`disconnected` event in JavaScript).</span></span>

    <span data-ttu-id="98ffc-209">Uruchamiany po upływie limitu czasu rozłączenia, gdy kod klienta sygnalizującego próbuje ponownie nawiązać połączenie po utracie połączenia transportowego.</span><span class="sxs-lookup"><span data-stu-id="98ffc-209">Raised when the disconnect timeout period expires while the SignalR client code is trying to reconnect after losing the transport connection.</span></span> <span data-ttu-id="98ffc-210">Domyślny limit czasu rozłączenia wynosi 30 sekund.</span><span class="sxs-lookup"><span data-stu-id="98ffc-210">The default disconnect timeout is 30 seconds.</span></span> <span data-ttu-id="98ffc-211">(To zdarzenie jest również wywoływane, gdy połączenie zostanie zakończone, ponieważ metoda `Stop` jest wywoływana).</span><span class="sxs-lookup"><span data-stu-id="98ffc-211">(This event is also raised when the connection ends because the `Stop` method is called.)</span></span>

<span data-ttu-id="98ffc-212">Przerwania połączenia transportowego, które nie są wykrywane przez interfejs API transportu i nie opóźnią odbierania poleceń ping o utrzymywaniu aktywności z serwera dłużej niż okres ostrzegawczy limitu czasu utrzymywania aktywności, mogą nie spowodować wystąpienia zdarzeń istnienia połączenia.</span><span class="sxs-lookup"><span data-stu-id="98ffc-212">Transport connection interruptions that are not detected by the transport API and don't delay the reception of keepalive pings from the server for longer than the keepalive timeout warning period might not cause any connection lifetime events to be raised.</span></span>

<span data-ttu-id="98ffc-213">Niektóre środowiska sieciowe świadomie zamykają połączenia bezczynne, a inna funkcja pakietów utrzymywania aktywności polega na tym, że te sieci wiedzą, że połączenie sygnalizujące jest w użyciu.</span><span class="sxs-lookup"><span data-stu-id="98ffc-213">Some network environments deliberately close idle connections, and another function of the keepalive packets is to help prevent this by letting these networks know that a SignalR connection is in use.</span></span> <span data-ttu-id="98ffc-214">W skrajnych przypadkach domyślna częstotliwość działania poleceń ping z utrzymywaniem aktywności może być niewystarczająca, aby zapobiec zamkniętym nawiązywaniu połączeń.</span><span class="sxs-lookup"><span data-stu-id="98ffc-214">In extreme cases the default frequency of keepalive pings might not be enough to prevent closed connections.</span></span> <span data-ttu-id="98ffc-215">W takim przypadku można skonfigurować polecenie ping o utrzymywanie aktywności, aby było wysyłane częściej.</span><span class="sxs-lookup"><span data-stu-id="98ffc-215">In that case you can configure keepalive pings to be sent more often.</span></span> <span data-ttu-id="98ffc-216">Aby uzyskać więcej informacji, zobacz [Ustawienia limitu czasu i utrzymywania aktywności](#timeoutkeepalive) w dalszej części tego tematu.</span><span class="sxs-lookup"><span data-stu-id="98ffc-216">For more information, see [Timeout and keepalive settings](#timeoutkeepalive) later in this topic.</span></span>

> [!NOTE] 
> 
> [!IMPORTANT]
> <span data-ttu-id="98ffc-217">Sekwencja zdarzeń opisana tutaj nie jest gwarantowana.</span><span class="sxs-lookup"><span data-stu-id="98ffc-217">The sequence of events described here is not guaranteed.</span></span> <span data-ttu-id="98ffc-218">Program sygnalizujący podejmuje próbę zgłoszenia zdarzeń okresu istnienia połączenia w przewidywalny sposób zgodnie z tym schematem, ale istnieje wiele wariantów zdarzeń sieciowych i wiele sposobów, w których podstawowe struktury komunikacji, takie jak interfejsy API transportu, obsługują je.</span><span class="sxs-lookup"><span data-stu-id="98ffc-218">SignalR makes every attempt to raise connection lifetime events in a predictable manner according to this scheme, but there are many variations of network events and many ways in which underlying communications frameworks such as transport APIs handle them.</span></span> <span data-ttu-id="98ffc-219">Na przykład zdarzenie `Reconnected` może nie zostać zgłoszone, gdy klient ponownie nawiązuje połączenie, lub procedura obsługi `OnConnected` na serwerze może zostać uruchomiona, gdy próba nawiązania połączenia nie powiedzie się.</span><span class="sxs-lookup"><span data-stu-id="98ffc-219">For example, the `Reconnected` event might not be raised when the client reconnects, or the `OnConnected` handler on the server might run when the attempt to establish a connection is unsuccessful.</span></span> <span data-ttu-id="98ffc-220">W tym temacie opisano tylko efekty, które zwykle są wytwarzane przez niektóre typowe okoliczności.</span><span class="sxs-lookup"><span data-stu-id="98ffc-220">This topic describes only the effects that would normally be produced by certain typical circumstances.</span></span>

<a id="clientdisconnect"></a>

### <a name="client-disconnection-scenarios"></a><span data-ttu-id="98ffc-221">Scenariusze rozłączenia klientów</span><span class="sxs-lookup"><span data-stu-id="98ffc-221">Client disconnection scenarios</span></span>

<span data-ttu-id="98ffc-222">W kliencie przeglądarki kod klienta sygnalizującego, który utrzymuje połączenie sygnalizujące, jest uruchamiany w kontekście JavaScript strony sieci Web.</span><span class="sxs-lookup"><span data-stu-id="98ffc-222">In a browser client, the SignalR client code that maintains a SignalR connection runs in the JavaScript context of a web page.</span></span> <span data-ttu-id="98ffc-223">To dlatego, że połączenie sygnalizujące ma kończyć się po przejściu z jednej strony do drugiej i dlatego masz wiele połączeń z wieloma identyfikatorami połączenia, jeśli łączysz się z wielu okien przeglądarki lub kart.</span><span class="sxs-lookup"><span data-stu-id="98ffc-223">That's why the SignalR connection has to end when you navigate from one page to another, and that's why you have multiple connections with multiple connection IDs if you connect from multiple browser windows or tabs.</span></span> <span data-ttu-id="98ffc-224">Gdy użytkownik zamknie okno lub kartę przeglądarki lub nawiguje do nowej strony lub odświeża stronę, połączenie sygnalizujące następuje natychmiast, ponieważ kod klienta sygnalizującego obsługuje to zdarzenie przeglądarki i wywołuje metodę `Stop`.</span><span class="sxs-lookup"><span data-stu-id="98ffc-224">When the user closes a browser window or tab, or navigates to a new page or refreshes the page, the SignalR connection immediately ends because SignalR client code handles that browser event for you and calls the `Stop` method.</span></span> <span data-ttu-id="98ffc-225">W tych scenariuszach lub na dowolnej platformie klienta, gdy aplikacja wywołuje metodę `Stop`, program obsługi zdarzeń `OnDisconnected` jest wykonywany natychmiast na serwerze, a klient zgłasza zdarzenie `Closed` (zdarzenie ma nazwę `disconnected` w języku JavaScript).</span><span class="sxs-lookup"><span data-stu-id="98ffc-225">In these scenarios, or in any client platform when your application calls the `Stop` method, the `OnDisconnected` event handler executes immediately on the server and the client raises the `Closed` event (the event is named `disconnected` in JavaScript).</span></span>

<span data-ttu-id="98ffc-226">Jeśli aplikacja kliencka lub komputer, na którym działa awaria lub przejdzie do trybu uśpienia (na przykład gdy użytkownik zamknie laptop), serwer nie zostanie poinformowany o tym, co się stało.</span><span class="sxs-lookup"><span data-stu-id="98ffc-226">If a client application or the computer that it's running on crashes or goes to sleep (for example, when the user closes the laptop), the server is not informed about what happened.</span></span> <span data-ttu-id="98ffc-227">W miarę jak serwer wie, że utrata klienta może być spowodowana przerwaniem łączności, a klient może próbować ponownie nawiązać połączenie.</span><span class="sxs-lookup"><span data-stu-id="98ffc-227">As far as the server knows, the loss of the client might be due to connectivity interruption and the client might be trying to reconnect.</span></span> <span data-ttu-id="98ffc-228">Dlatego w tych scenariuszach serwer czeka, aby klient mógł ponownie nawiązać połączenie, a `OnDisconnected` nie wykonywał do momentu wygaśnięcia okresu rozłączenia (domyślnie około 30 sekund).</span><span class="sxs-lookup"><span data-stu-id="98ffc-228">Therefore, in these scenarios the server waits to give the client a chance to reconnect, and `OnDisconnected` does not execute until the disconnect timeout period expires (about 30 seconds by default).</span></span> <span data-ttu-id="98ffc-229">Na poniższym diagramie przedstawiono ten scenariusz.</span><span class="sxs-lookup"><span data-stu-id="98ffc-229">The following diagram illustrates this scenario.</span></span>

![Awaria komputera klienckiego](handling-connection-lifetime-events/_static/image4.png)

<a id="serverdisconnect"></a>

### <a name="server-disconnection-scenarios"></a><span data-ttu-id="98ffc-231">Scenariusze odłączenia serwera</span><span class="sxs-lookup"><span data-stu-id="98ffc-231">Server disconnection scenarios</span></span>

<span data-ttu-id="98ffc-232">Gdy serwer przejdzie w tryb offline — wykonuje ponowny rozruch, Niepowodzenie, odzyskanie domeny aplikacji itp. — wynik może być podobny do utraconego połączenia lub interfejs API transportu i sygnalizujący może się natychmiast dowiedzieć, że serwer został usunięty, a sygnalizujący spróbuje ponownie nawiązać połączenie bez podnoszenia zdarzenia `ConnectionSlow`.</span><span class="sxs-lookup"><span data-stu-id="98ffc-232">When a server goes offline -- it reboots, fails, the app domain recycles, etc. -- the result might be similar to a lost connection, or the transport API and SignalR might know immediately that the server is gone, and SignalR might begin trying to reconnect without raising the `ConnectionSlow` event.</span></span> <span data-ttu-id="98ffc-233">Jeśli klient przejdzie w tryb ponownej łączności, a jeśli serwer odzyska lub uruchomi ponownie lub nowy serwer zostanie przełączony w tryb online przed upływem limitu czasu rozłączenia, klient ponownie nawiąże połączenie z przywróconym lub nowym serwerem.</span><span class="sxs-lookup"><span data-stu-id="98ffc-233">If the client goes into reconnecting mode, and if the server recovers or restarts or a new server is brought online before the disconnect timeout period expires, the client will reconnect to the restored or new server.</span></span> <span data-ttu-id="98ffc-234">W takim przypadku połączenie sygnalizujące kontynuuje się na kliencie i zostanie zgłoszone zdarzenie `Reconnected`.</span><span class="sxs-lookup"><span data-stu-id="98ffc-234">In that case, the SignalR connection continues on the client and the `Reconnected` event is raised.</span></span> <span data-ttu-id="98ffc-235">Na pierwszym serwerze `OnDisconnected` nigdy nie są wykonywane i na nowym serwerze `OnReconnected` jest wykonywane, mimo że `OnConnected` nigdy nie były wykonywane dla tego klienta na tym serwerze.</span><span class="sxs-lookup"><span data-stu-id="98ffc-235">On the first server, `OnDisconnected` is never executed, and on the new server, `OnReconnected` is executed although `OnConnected` was never executed for that client on that server before.</span></span> <span data-ttu-id="98ffc-236">(Efekt jest taki sam, jeśli klient ponownie nawiązuje połączenie z tym samym serwerem po ponownym uruchomieniu lub odtworzeniu domeny aplikacji), ponieważ po ponownym uruchomieniu serwera nie ma pamięci z poprzednią aktywnością połączenia. Na poniższym diagramie założono, że interfejs API transportu będzie miał natychmiastową świadomość utraconych połączeń, więc zdarzenie `ConnectionSlow` nie zostanie zgłoszone.</span><span class="sxs-lookup"><span data-stu-id="98ffc-236">(The effect is the same if the client reconnects to the same server after a reboot or app domain recycle, because when the server restarts it has no memory of prior connection activity.) The following diagram assumes that the transport API becomes aware of the lost connection immediately, so the `ConnectionSlow` event is not raised.</span></span>

![Awaria serwera i ponowne połączenie](handling-connection-lifetime-events/_static/image5.png)

<span data-ttu-id="98ffc-238">Jeśli serwer nie stanie się dostępny w ramach limitu czasu rozłączenia, połączenie sygnalizujące się zakończy.</span><span class="sxs-lookup"><span data-stu-id="98ffc-238">If a server does not become available within the disconnect timeout period, the SignalR connection ends.</span></span> <span data-ttu-id="98ffc-239">W tym scenariuszu na kliencie zostanie zgłoszone zdarzenie `Closed` (`disconnected` na klientach JavaScript), ale na serwerze nie jest nigdy wywoływana `OnDisconnected`.</span><span class="sxs-lookup"><span data-stu-id="98ffc-239">In this scenario, the `Closed` event (`disconnected` in JavaScript clients) is raised on the client but `OnDisconnected` is never called on the server.</span></span> <span data-ttu-id="98ffc-240">Na poniższym diagramie przyjęto założenie, że interfejs API transportu nie ma informacji o utraconym połączeniu, więc jest wykrywany przez funkcję utrzymywania aktywności sygnału i zostanie zgłoszone zdarzenie `ConnectionSlow`.</span><span class="sxs-lookup"><span data-stu-id="98ffc-240">The following diagram assumes that the transport API does not become aware of the lost connection, so it is detected by SignalR keepalive functionality and the `ConnectionSlow` event is raised.</span></span>

![Awaria serwera i przekroczenie limitu czasu](handling-connection-lifetime-events/_static/image6.png)

<a id="timeoutkeepalive"></a>

## <a name="timeout-and-keepalive-settings"></a><span data-ttu-id="98ffc-242">Ustawienia limitu czasu i utrzymywania aktywności</span><span class="sxs-lookup"><span data-stu-id="98ffc-242">Timeout and keepalive settings</span></span>

<span data-ttu-id="98ffc-243">Wartości domyślne `ConnectionTimeout`, `DisconnectTimeout`i `KeepAlive` są odpowiednie dla większości scenariuszy, ale można je zmienić, jeśli środowisko ma specjalne potrzeby.</span><span class="sxs-lookup"><span data-stu-id="98ffc-243">The default `ConnectionTimeout`, `DisconnectTimeout`, and `KeepAlive` values are appropriate for most scenarios but can be changed if your environment has special needs.</span></span> <span data-ttu-id="98ffc-244">Na przykład jeśli środowisko sieciowe zamyka połączenia, które są bezczynne przez 5 sekund, może być konieczne zmniejszenie wartości utrzymywania aktywności.</span><span class="sxs-lookup"><span data-stu-id="98ffc-244">For example, if your network environment closes connections that are idle for 5 seconds, you might have to decrease the keepalive value.</span></span>

<a id="connectiontimeout"></a>

### <a name="connectiontimeout"></a><span data-ttu-id="98ffc-245">Parametru</span><span class="sxs-lookup"><span data-stu-id="98ffc-245">ConnectionTimeout</span></span>

<span data-ttu-id="98ffc-246">To ustawienie określa czas, w którym połączenie transportowe zostanie otwarte i oczekuje na odpowiedź przed zamknięciem i otwarciem nowego połączenia.</span><span class="sxs-lookup"><span data-stu-id="98ffc-246">This setting represents the amount of time to leave a transport connection open and waiting for a response before closing it and opening a new connection.</span></span> <span data-ttu-id="98ffc-247">Wartość domyślna to 110 sekund.</span><span class="sxs-lookup"><span data-stu-id="98ffc-247">The default value is 110 seconds.</span></span>

<span data-ttu-id="98ffc-248">To ustawienie ma zastosowanie tylko wtedy, gdy funkcja utrzymywania aktywności jest wyłączona, która zwykle dotyczy tylko długiego transportu sondowania.</span><span class="sxs-lookup"><span data-stu-id="98ffc-248">This setting applies only when keepalive functionality is disabled, which normally applies only to the long polling transport.</span></span> <span data-ttu-id="98ffc-249">Na poniższym diagramie przedstawiono efekt tego ustawienia dla długiego połączenia transportowego sondowania.</span><span class="sxs-lookup"><span data-stu-id="98ffc-249">The following diagram illustrates the effect of this setting on a long polling transport connection.</span></span>

![Długie sondowanie połączenia transportowego](handling-connection-lifetime-events/_static/image7.png)

<a id="disconnecttimeout"></a>

### <a name="disconnecttimeout"></a><span data-ttu-id="98ffc-251">DisconnectTimeout</span><span class="sxs-lookup"><span data-stu-id="98ffc-251">DisconnectTimeout</span></span>

<span data-ttu-id="98ffc-252">To ustawienie reprezentuje czas oczekiwania po utracie połączenia transportowego przed podniesieniem zdarzenia `Disconnected`.</span><span class="sxs-lookup"><span data-stu-id="98ffc-252">This setting represents the amount of time to wait after a transport connection is lost before raising the `Disconnected` event.</span></span> <span data-ttu-id="98ffc-253">Wartość domyślna to 30 sekund.</span><span class="sxs-lookup"><span data-stu-id="98ffc-253">The default value is 30 seconds.</span></span> <span data-ttu-id="98ffc-254">Po ustawieniu `DisconnectTimeout`, `KeepAlive` jest automatycznie ustawiany na 1/3 wartości `DisconnectTimeout`.</span><span class="sxs-lookup"><span data-stu-id="98ffc-254">When you set `DisconnectTimeout`, `KeepAlive` is automatically set to 1/3 of the `DisconnectTimeout` value.</span></span>

<a id="keepalive"></a>

### <a name="keepalive"></a><span data-ttu-id="98ffc-255">KeepAlive</span><span class="sxs-lookup"><span data-stu-id="98ffc-255">KeepAlive</span></span>

<span data-ttu-id="98ffc-256">To ustawienie reprezentuje czas oczekiwania przed wysłaniem pakietu w trybie utrzymywania aktywności przez bezczynne połączenie.</span><span class="sxs-lookup"><span data-stu-id="98ffc-256">This setting represents the amount of time to wait before sending a keepalive packet over an idle connection.</span></span> <span data-ttu-id="98ffc-257">Wartość domyślna to 10 sekund.</span><span class="sxs-lookup"><span data-stu-id="98ffc-257">The default value is 10 seconds.</span></span> <span data-ttu-id="98ffc-258">Ta wartość nie może być większa niż 1/3 wartości `DisconnectTimeout`.</span><span class="sxs-lookup"><span data-stu-id="98ffc-258">This value must not be more than 1/3 of the `DisconnectTimeout` value.</span></span>

<span data-ttu-id="98ffc-259">Jeśli chcesz ustawić zarówno `DisconnectTimeout`, jak i `KeepAlive`, ustaw `KeepAlive` po `DisconnectTimeout`.</span><span class="sxs-lookup"><span data-stu-id="98ffc-259">If you want to set both `DisconnectTimeout` and `KeepAlive`, set `KeepAlive` after `DisconnectTimeout`.</span></span> <span data-ttu-id="98ffc-260">W przeciwnym razie ustawienie `KeepAlive` zostanie nadpisane, gdy `DisconnectTimeout` automatycznie ustawi `KeepAlive` na 1/3 wartości limitu czasu.</span><span class="sxs-lookup"><span data-stu-id="98ffc-260">Otherwise your `KeepAlive` setting will be overwritten when `DisconnectTimeout` automatically sets `KeepAlive` to 1/3 of the timeout value.</span></span>

<span data-ttu-id="98ffc-261">Jeśli chcesz wyłączyć funkcję utrzymywania aktywności, ustaw `KeepAlive` na wartość null.</span><span class="sxs-lookup"><span data-stu-id="98ffc-261">If you want to disable keepalive functionality, set `KeepAlive` to null.</span></span> <span data-ttu-id="98ffc-262">Funkcja utrzymywania aktywności jest automatycznie wyłączana dla długiego transportu sondowania.</span><span class="sxs-lookup"><span data-stu-id="98ffc-262">Keepalive functionality is automatically disabled for the long polling transport.</span></span>

<a id="changetimeout"></a>

### <a name="how-to-change-timeout-and-keepalive-settings"></a><span data-ttu-id="98ffc-263">Jak zmienić limit czasu i ustawienia utrzymywania aktywności</span><span class="sxs-lookup"><span data-stu-id="98ffc-263">How to change timeout and keepalive settings</span></span>

<span data-ttu-id="98ffc-264">Aby zmienić wartości domyślne dla tych ustawień, należy ustawić je w `Application_Start` w pliku *Global. asax* , jak pokazano w poniższym przykładzie.</span><span class="sxs-lookup"><span data-stu-id="98ffc-264">To change the default values for these settings, set them in `Application_Start` in your *Global.asax* file, as shown in the following example.</span></span> <span data-ttu-id="98ffc-265">Wartości wyświetlane w przykładowym kodzie są takie same jak wartości domyślne.</span><span class="sxs-lookup"><span data-stu-id="98ffc-265">The values shown in the sample code are the same as the default values.</span></span>

[!code-csharp[Main](handling-connection-lifetime-events/samples/sample1.cs)]

<a id="notifydisconnect"></a>

## <a name="how-to-notify-the-user-about-disconnections"></a><span data-ttu-id="98ffc-266">Jak powiadomić użytkownika o rozwiązaniu</span><span class="sxs-lookup"><span data-stu-id="98ffc-266">How to notify the user about disconnections</span></span>

<span data-ttu-id="98ffc-267">W niektórych aplikacjach możesz chcieć wyświetlić komunikat dla użytkownika w przypadku problemów z łącznością.</span><span class="sxs-lookup"><span data-stu-id="98ffc-267">In some applications you might want to display a message to the user when there are connectivity problems.</span></span> <span data-ttu-id="98ffc-268">Istnieje kilka opcji, które należy wykonać, aby to zrobić.</span><span class="sxs-lookup"><span data-stu-id="98ffc-268">You have several options for how and when to do this.</span></span> <span data-ttu-id="98ffc-269">Poniższe przykłady kodu są przeznaczone dla klienta JavaScript korzystającego z wygenerowanego serwera proxy.</span><span class="sxs-lookup"><span data-stu-id="98ffc-269">The following code samples are for a JavaScript client using the generated proxy.</span></span>

- <span data-ttu-id="98ffc-270">Obsłuż zdarzenie `connectionSlow`, aby wyświetlić komunikat, gdy tylko sygnał jest świadomy problemów z połączeniem, przed przejściem do trybu ponownego łączenia.</span><span class="sxs-lookup"><span data-stu-id="98ffc-270">Handle the `connectionSlow` event to display a message as soon as SignalR is aware of connection problems, before it goes into reconnecting mode.</span></span>

    [!code-javascript[Main](handling-connection-lifetime-events/samples/sample2.js)]
- <span data-ttu-id="98ffc-271">Obsłuż zdarzenie `reconnecting`, aby wyświetlić komunikat, gdy sygnał zostanie powiadomiony o rozwiązaniu rozłączenia i nastąpi ponowne połączenie z trybem.</span><span class="sxs-lookup"><span data-stu-id="98ffc-271">Handle the `reconnecting` event to display a message when SignalR is aware of a disconnection and is going into reconnecting mode.</span></span>

    [!code-javascript[Main](handling-connection-lifetime-events/samples/sample3.js)]
- <span data-ttu-id="98ffc-272">Obsłuż zdarzenie `disconnected`, aby wyświetlić komunikat w przypadku przekroczenia limitu czasu próby ponownego nawiązania połączenia. W tym scenariuszu jedynym sposobem ponownego nawiązania połączenia z serwerem jest ponowne uruchomienie połączenia sygnalizującego przez wywołanie metody `Start`, która utworzy nowy identyfikator połączenia.</span><span class="sxs-lookup"><span data-stu-id="98ffc-272">Handle the `disconnected` event to display a message when an attempt to reconnect has timed out. In this scenario, the only way to re-establish a connection with the server again is to restart the SignalR connection by calling the `Start` method, which will create a new connection ID.</span></span> <span data-ttu-id="98ffc-273">Poniższy przykład kodu używa flagi, aby upewnić się, że powiadomienia są wystawiane dopiero po upływie limitu czasu ponownego połączenia, a nie po normalnym zakończeniu połączenia sygnalizującego spowodowanym wywołaniem metody `Stop`.</span><span class="sxs-lookup"><span data-stu-id="98ffc-273">The following code sample uses a flag to make sure that you issue the notification only after a reconnecting timeout, not after a normal end to the SignalR connection caused by calling the `Stop` method.</span></span>

    [!code-javascript[Main](handling-connection-lifetime-events/samples/sample4.js)]

<a id="continuousreconnect"></a>

## <a name="how-to-continuously-reconnect"></a><span data-ttu-id="98ffc-274">Jak ciągle ponownie nawiązać połączenie</span><span class="sxs-lookup"><span data-stu-id="98ffc-274">How to continuously reconnect</span></span>

<span data-ttu-id="98ffc-275">W niektórych aplikacjach warto automatycznie ponownie nawiązać połączenie po jego utracie, a próba ponownego nawiązania połączenia przekroczyła limit czasu. W tym celu można wywołać metodę `Start` z programu obsługi zdarzeń `Closed` (program obsługi zdarzeń`disconnected` na klientach JavaScript).</span><span class="sxs-lookup"><span data-stu-id="98ffc-275">In some applications you might want to automatically re-establish a connection after it has been lost and the attempt to reconnect has timed out. To do that, you can call the `Start` method from your `Closed` event handler (`disconnected` event handler on JavaScript clients).</span></span> <span data-ttu-id="98ffc-276">Może upłynąć pewien czas przed wywołaniem `Start`, aby uniknąć tego zbyt często, gdy serwer lub połączenie fizyczne są niedostępne.</span><span class="sxs-lookup"><span data-stu-id="98ffc-276">You might want to wait a period of time before calling `Start` in order to avoid doing this too frequently when the server or the physical connection are unavailable.</span></span> <span data-ttu-id="98ffc-277">Poniższy przykład kodu dotyczy klienta JavaScript korzystającego z wygenerowanego serwera proxy.</span><span class="sxs-lookup"><span data-stu-id="98ffc-277">The following code sample is for a JavaScript client using the generated proxy.</span></span>

[!code-javascript[Main](handling-connection-lifetime-events/samples/sample5.js)]

<span data-ttu-id="98ffc-278">Potencjalnym problemem, które należy znać w przypadku klientów mobilnych, jest to, że ciągłe Ponowne nawiązywanie połączenia, gdy serwer lub połączenie fizyczne nie jest dostępne, może spowodować niepotrzebną utratę baterii.</span><span class="sxs-lookup"><span data-stu-id="98ffc-278">A potential problem to be aware of in mobile clients is that continuous reconnection attempts when the server or physical connection isn't available could cause unnecessary battery drain.</span></span>

<a id="disconnectclientfromserver"></a>

## <a name="how-to-disconnect-a-client-in-server-code"></a><span data-ttu-id="98ffc-279">Jak rozłączyć klienta w kodzie serwera</span><span class="sxs-lookup"><span data-stu-id="98ffc-279">How to disconnect a client in server code</span></span>

<span data-ttu-id="98ffc-280">System sygnalizujący w wersji 1.1.1 nie ma wbudowanego interfejsu API serwera do odłączenia klientów.</span><span class="sxs-lookup"><span data-stu-id="98ffc-280">SignalR version 1.1.1 does not have a built-in server API for disconnecting clients.</span></span> <span data-ttu-id="98ffc-281">Istnieją [plany dodawania tych funkcji w przyszłości](https://github.com/SignalR/SignalR/issues/2101).</span><span class="sxs-lookup"><span data-stu-id="98ffc-281">There are [plans for adding this functionality in the future](https://github.com/SignalR/SignalR/issues/2101).</span></span> <span data-ttu-id="98ffc-282">W bieżącej wersji sygnalizującej Najprostszym sposobem rozłączenia klienta z serwera jest zaimplementowanie metody Disconnect na kliencie i wywołanie tej metody z serwera.</span><span class="sxs-lookup"><span data-stu-id="98ffc-282">In the current SignalR release, the simplest way to disconnect a client from the server is to implement a disconnect method on the client and call that method from the server.</span></span> <span data-ttu-id="98ffc-283">Poniższy przykładowy kod przedstawia metodę Disconnect dla klienta JavaScript przy użyciu wygenerowanego serwera proxy.</span><span class="sxs-lookup"><span data-stu-id="98ffc-283">The following code sample shows a disconnect method for a JavaScript client using the generated proxy.</span></span>

[!code-javascript[Main](handling-connection-lifetime-events/samples/sample6.js)]

> [!WARNING]
> <span data-ttu-id="98ffc-284">Zabezpieczenia — ani ta metoda odłączania klientów i proponowany wbudowany interfejs API będzie zawierać scenariusz zaatakowana klientów, którzy uruchamiają złośliwy kod, ponieważ klienci mogą ponownie nawiązać połączenie lub kod zaatakowana może usunąć metodę `stopClient` lub zmienić jej działanie.</span><span class="sxs-lookup"><span data-stu-id="98ffc-284">Security - Neither this method for disconnecting clients nor the proposed built-in API will address the scenario of hacked clients that are running malicious code, since the clients could reconnect or the hacked code might remove the `stopClient` method or change what it does.</span></span> <span data-ttu-id="98ffc-285">Odpowiednie miejsce na wdrożenie ochrony stanowej "odmowa usługi" (DOS) nie znajduje się w strukturze ani warstwie serwera, ale raczej w infrastrukturze frontonu.</span><span class="sxs-lookup"><span data-stu-id="98ffc-285">The appropriate place to implement stateful denial-of-service (DOS) protection is not in the framework or the server layer, but rather in front-end infrastructure.</span></span>
