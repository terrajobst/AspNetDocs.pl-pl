---
uid: mvc/overview/older-versions-1/nerddinner/use-viewdata-and-implement-viewmodel-classes
title: Korzystanie z ViewData i implementowanie klas ViewModel | Microsoft Docs
author: microsoft
description: Krok 6 pokazuje, jak włączyć obsługę bogatszych scenariuszy edycji formularzy, a także omówiono dwa podejścia, których można użyć do przekazywania danych z kontrolerów do widoków:...
ms.author: riande
ms.date: 07/27/2010
ms.assetid: 5755ec4c-60f1-4057-9ec0-3a5de3a20e23
msc.legacyurl: /mvc/overview/older-versions-1/nerddinner/use-viewdata-and-implement-viewmodel-classes
msc.type: authoredcontent
ms.openlocfilehash: ca9775417c2e25952511a73096fb76d5d4edaea2
ms.sourcegitcommit: e7e91932a6e91a63e2e46417626f39d6b244a3ab
ms.translationtype: MT
ms.contentlocale: pl-PL
ms.lasthandoff: 03/06/2020
ms.locfileid: "78541609"
---
# <a name="use-viewdata-and-implement-viewmodel-classes"></a><span data-ttu-id="80619-103">Korzystanie z podejścia ViewData i implementowanie klas ViewModel</span><span class="sxs-lookup"><span data-stu-id="80619-103">Use ViewData and Implement ViewModel Classes</span></span>

<span data-ttu-id="80619-104">przez [firmę Microsoft](https://github.com/microsoft)</span><span class="sxs-lookup"><span data-stu-id="80619-104">by [Microsoft](https://github.com/microsoft)</span></span>

[<span data-ttu-id="80619-105">Pobierz plik PDF</span><span class="sxs-lookup"><span data-stu-id="80619-105">Download PDF</span></span>](http://aspnetmvcbook.s3.amazonaws.com/aspnetmvc-nerdinner_v1.pdf)

> <span data-ttu-id="80619-106">Jest to krok 6 bezpłatnego [samouczka dotyczącego aplikacji "NerdDinner"](introducing-the-nerddinner-tutorial.md) , który zawiera instrukcje tworzenia niewielkiej, ale kompletnej aplikacji sieci Web przy użyciu ASP.NET MVC 1.</span><span class="sxs-lookup"><span data-stu-id="80619-106">This is step 6 of a free ["NerdDinner" application tutorial](introducing-the-nerddinner-tutorial.md) that walks-through how to build a small, but complete, web application using ASP.NET MVC 1.</span></span>
> 
> <span data-ttu-id="80619-107">Krok 6 pokazuje, jak włączyć obsługę bogatszych scenariuszy edycji formularzy, a także omówiono dwa podejścia, których można użyć do przekazywania danych z kontrolerów do widoków: ViewData i ViewModel.</span><span class="sxs-lookup"><span data-stu-id="80619-107">Step 6 shows how enable support for richer form editing scenarios, and also discusses two approaches that can be used to pass data from controllers to views: ViewData and ViewModel.</span></span>
> 
> <span data-ttu-id="80619-108">Jeśli używasz ASP.NET MVC 3, zalecamy użycie [wprowadzenie ze samouczkami ze sklepu MVC 3](../../older-versions/getting-started-with-aspnet-mvc3/cs/intro-to-aspnet-mvc-3.md) lub [MVC](../../older-versions/mvc-music-store/mvc-music-store-part-1.md) .</span><span class="sxs-lookup"><span data-stu-id="80619-108">If you are using ASP.NET MVC 3, we recommend you follow the [Getting Started With MVC 3](../../older-versions/getting-started-with-aspnet-mvc3/cs/intro-to-aspnet-mvc-3.md) or [MVC Music Store](../../older-versions/mvc-music-store/mvc-music-store-part-1.md) tutorials.</span></span>

## <a name="nerddinner-step-6-viewdata-and-viewmodel"></a><span data-ttu-id="80619-109">NerdDinner krok 6: ViewData i ViewModel</span><span class="sxs-lookup"><span data-stu-id="80619-109">NerdDinner Step 6: ViewData and ViewModel</span></span>

<span data-ttu-id="80619-110">Omówiono kilka scenariuszy post formularzy i omówiono sposób implementacji obsługi tworzenia, aktualizowania i usuwania (CRUD).</span><span class="sxs-lookup"><span data-stu-id="80619-110">We've covered a number of form post scenarios, and discussed how to implement create, update and delete (CRUD) support.</span></span> <span data-ttu-id="80619-111">Teraz zajmiemy się implementacją DinnersController i umożliwimy obsługę bogatszych scenariuszy edycji formularzy.</span><span class="sxs-lookup"><span data-stu-id="80619-111">We'll now take our DinnersController implementation further and enable support for richer form editing scenarios.</span></span> <span data-ttu-id="80619-112">W tym celu omawiamy dwie podejścia, których można użyć do przekazywania danych z kontrolerów do widoków: ViewData i ViewModel.</span><span class="sxs-lookup"><span data-stu-id="80619-112">While doing this we'll discuss two approaches that can be used to pass data from controllers to views: ViewData and ViewModel.</span></span>

### <a name="passing-data-from-controllers-to-view-templates"></a><span data-ttu-id="80619-113">Przekazywanie danych z kontrolerów do widoków-szablonów</span><span class="sxs-lookup"><span data-stu-id="80619-113">Passing Data from Controllers to View-Templates</span></span>

<span data-ttu-id="80619-114">Jedną z cech definicji wzorca MVC jest ścisłe "separacja obaw", które ułatwiają wymuszanie między różnymi składnikami aplikacji.</span><span class="sxs-lookup"><span data-stu-id="80619-114">One of the defining characteristics of the MVC pattern is the strict "separation of concerns" it helps enforce between the different components of an application.</span></span> <span data-ttu-id="80619-115">Modele, kontrolery i widoki mają dobrze zdefiniowane role i obowiązki, a także komunikują się między sobą.</span><span class="sxs-lookup"><span data-stu-id="80619-115">Models, Controllers and Views each have well defined roles and responsibilities, and they communicate amongst each other in well defined ways.</span></span> <span data-ttu-id="80619-116">Pozwala to na podwyższenie możliwości testowania i ponownego użycia kodu.</span><span class="sxs-lookup"><span data-stu-id="80619-116">This helps promote testability and code reuse.</span></span>

<span data-ttu-id="80619-117">Gdy klasa kontrolera zdecyduje się na renderowanie odpowiedzi HTML z powrotem do klienta, jest odpowiedzialna za jawne przekazanie do szablonu widoku wszystkich danych wymaganych do renderowania odpowiedzi.</span><span class="sxs-lookup"><span data-stu-id="80619-117">When a Controller class decides to render an HTML response back to a client, it is responsible for explicitly passing to the view template all of the data needed to render the response.</span></span> <span data-ttu-id="80619-118">Szablony widoków nigdy nie wykonują żadnych operacji pobierania danych ani logiki aplikacji — a zamiast tego ograniczają się tylko do kodu renderowania, który jest oparty na modelu/danych przekazanego do niego przez kontroler.</span><span class="sxs-lookup"><span data-stu-id="80619-118">View templates should never perform any data retrieval or application logic – and should instead limit themselves to only have rendering code that is driven off of the model/data passed to it by the controller.</span></span>

<span data-ttu-id="80619-119">Teraz dane modelu przekazywane przez naszą klasę DinnersController do naszych szablonów widoku są proste i proste — do przodu — lista obiektów obiadu w przypadku indeksu () i pojedynczy obiekt obiadu w przypadku szczegółów (), Edit (), Create () i Delete ().</span><span class="sxs-lookup"><span data-stu-id="80619-119">Right now the model data being passed by our DinnersController class to our view templates is simple and straight-forward – a list of Dinner objects in the case of Index(), and a single Dinner object in the case of Details(), Edit(), Create() and Delete().</span></span> <span data-ttu-id="80619-120">Po dodaniu większej liczby funkcji interfejsu użytkownika do aplikacji często będziemy musieli przekazać więcej niż tylko te dane, aby renderować odpowiedzi HTML w naszych szablonach widoków.</span><span class="sxs-lookup"><span data-stu-id="80619-120">As we add more UI capabilities to our application, we are often going to need to pass more than just this data to render HTML responses within our view templates.</span></span> <span data-ttu-id="80619-121">Na przykład możemy chcieć zmienić pole "Country" w naszym Edytuj i utworzyć widoki z pola tekstowego HTML na DropDownList.</span><span class="sxs-lookup"><span data-stu-id="80619-121">For example, we might want to change the "Country" field within our Edit and Create views from being an HTML textbox to a dropdownlist.</span></span> <span data-ttu-id="80619-122">Zamiast nakodować twardy listę rozwijaną nazw krajów w szablonie widoku, możemy wygenerować ją z listy obsługiwanych krajów, które wypełniamy dynamicznie.</span><span class="sxs-lookup"><span data-stu-id="80619-122">Rather than hard-code the dropdown list of country names in the view template, we might want to generate it from a list of supported countries that we populate dynamically.</span></span> <span data-ttu-id="80619-123">Będziemy musieli przekazać zarówno obiekt obiadu *, jak i* listę obsługiwanych krajów z naszego kontrolera do naszego szablonu widoku.</span><span class="sxs-lookup"><span data-stu-id="80619-123">We will need a way to pass both the Dinner object *and* the list of supported countries from our controller to our view templates.</span></span>

<span data-ttu-id="80619-124">Przyjrzyjmy się na dwa sposoby tego celu.</span><span class="sxs-lookup"><span data-stu-id="80619-124">Let's look at two ways we can accomplish this.</span></span>

### <a name="using-the-viewdata-dictionary"></a><span data-ttu-id="80619-125">Korzystanie z słownika ViewData</span><span class="sxs-lookup"><span data-stu-id="80619-125">Using the ViewData Dictionary</span></span>

<span data-ttu-id="80619-126">Klasa bazowa kontrolera uwidacznia Właściwość słownika "ViewData", która może służyć do przekazywania dodatkowych elementów danych z kontrolerów do widoków.</span><span class="sxs-lookup"><span data-stu-id="80619-126">The Controller base class exposes a "ViewData" dictionary property that can be used to pass additional data items from Controllers to Views.</span></span>

<span data-ttu-id="80619-127">Na przykład w celu obsługi scenariusza, w którym chcemy zmienić pole tekstowe "kraj" w naszym widoku edycji z pola tekstowego HTML na DropDownList, możemy zaktualizować metodę akcji Edytuj (), aby przekazać (oprócz obiektu obiad) obiekt SelectList, który może być używany jako m odelu krajów DropDownList.</span><span class="sxs-lookup"><span data-stu-id="80619-127">For example, to support the scenario where we want to change the "Country" textbox within our Edit view from being an HTML textbox to a dropdownlist, we can update our Edit() action method to pass (in addition to a Dinner object) a SelectList object that can be used as the model of a countries dropdownlist.</span></span>

[!code-csharp[Main](use-viewdata-and-implement-viewmodel-classes/samples/sample1.cs)]

<span data-ttu-id="80619-128">Konstruktor SelectList powyżej akceptuje listę countów, aby wypełnić polecenie Drop-downlist with, a także aktualnie wybraną wartość.</span><span class="sxs-lookup"><span data-stu-id="80619-128">The constructor of the SelectList above is accepting a list of counties to populate the drop-downlist with, as well as the currently selected value.</span></span>

<span data-ttu-id="80619-129">Następnie możemy zaktualizować nasz szablon widoku Edytuj. aspx, aby użyć metody pomocnika html. DropDownList () zamiast metody pomocnika html. TextBox (), która została użyta wcześniej:</span><span class="sxs-lookup"><span data-stu-id="80619-129">We can then update our Edit.aspx view template to use the Html.DropDownList() helper method instead of the Html.TextBox() helper method we used previously:</span></span>

[!code-aspx[Main](use-viewdata-and-implement-viewmodel-classes/samples/sample2.aspx)]

<span data-ttu-id="80619-130">Powyższa metoda pomocnika html. DropDownList () przyjmuje dwa parametry.</span><span class="sxs-lookup"><span data-stu-id="80619-130">The Html.DropDownList() helper method above takes two parameters.</span></span> <span data-ttu-id="80619-131">Pierwsza to nazwa elementu formularza HTML do wyprowadzenia.</span><span class="sxs-lookup"><span data-stu-id="80619-131">The first is the name of the HTML form element to output.</span></span> <span data-ttu-id="80619-132">Drugi jest modelem "SelectList", który został przesłany za pośrednictwem słownika ViewData.</span><span class="sxs-lookup"><span data-stu-id="80619-132">The second is the "SelectList" model we passed via the ViewData dictionary.</span></span> <span data-ttu-id="80619-133">Używamy słowa kluczowego C# "As" do rzutowania typu w słowniku jako SelectList.</span><span class="sxs-lookup"><span data-stu-id="80619-133">We are using the C# "as" keyword to cast the type within the dictionary as a SelectList.</span></span>

<span data-ttu-id="80619-134">Po uruchomieniu aplikacji i uzyskaniu dostępu do adresu URL */Dinners/Edit/1* w naszej przeglądarce zobaczymy, że nasz interfejs użytkownika edytowania został zaktualizowany tak, aby wyświetlał DropDownList krajów zamiast pola tekstowego:</span><span class="sxs-lookup"><span data-stu-id="80619-134">And now when we run our application and access the */Dinners/Edit/1* URL within our browser we'll see that our edit UI has been updated to display a dropdownlist of countries instead of a textbox:</span></span>

![](use-viewdata-and-implement-viewmodel-classes/_static/image1.png)

<span data-ttu-id="80619-135">Ponieważ renderuje również szablon widoku edycji z metody HTTP-POST Edit (w scenariuszach w przypadku wystąpienia błędów), chcemy upewnić się, że aktualizujemy również tę metodę, aby dodać SelectList do ViewData, gdy szablon widoku jest renderowany w scenariuszach błędów:</span><span class="sxs-lookup"><span data-stu-id="80619-135">Because we also render the Edit view template from the HTTP-POST Edit method (in scenarios when errors occur), we'll want to make sure that we also update this method to add the SelectList to ViewData when the view template is rendered in error scenarios:</span></span>

[!code-csharp[Main](use-viewdata-and-implement-viewmodel-classes/samples/sample3.cs)]

<span data-ttu-id="80619-136">A teraz nasz scenariusz edytowania DinnersController obsługuje DropDownList.</span><span class="sxs-lookup"><span data-stu-id="80619-136">And now our DinnersController edit scenario supports a DropDownList.</span></span>

### <a name="using-a-viewmodel-pattern"></a><span data-ttu-id="80619-137">Używanie wzorca ViewModel</span><span class="sxs-lookup"><span data-stu-id="80619-137">Using a ViewModel Pattern</span></span>

<span data-ttu-id="80619-138">Podejście słownikowe ViewData jest korzystne i łatwe do zaimplementowania.</span><span class="sxs-lookup"><span data-stu-id="80619-138">The ViewData dictionary approach has the benefit of being fairly fast and easy to implement.</span></span> <span data-ttu-id="80619-139">Niektórzy deweloperzy nie używają słowników opartych na ciągach, ale ponieważ literówki mogą prowadzić do błędów, które nie będą przechwytywane w czasie kompilacji.</span><span class="sxs-lookup"><span data-stu-id="80619-139">Some developers don't like using string-based dictionaries, though, since typos can lead to errors that will not be caught at compile-time.</span></span> <span data-ttu-id="80619-140">Słownik ViewData o nieokreślonym typie wymaga również użycia operatora "As" lub odlewania przy użyciu języka o jednoznacznie określonym typie C# , takiego jak w szablonie widoku.</span><span class="sxs-lookup"><span data-stu-id="80619-140">The un-typed ViewData dictionary also requires using the "as" operator or casting when using a strongly-typed language like C# in a view template.</span></span>

<span data-ttu-id="80619-141">Alternatywnym podejściem, którego można użyć, jest często nazywane wzorcem "ViewModel".</span><span class="sxs-lookup"><span data-stu-id="80619-141">An alternative approach that we could use is one often referred to as the "ViewModel" pattern.</span></span> <span data-ttu-id="80619-142">W przypadku korzystania z tego wzorca tworzymy klasy o jednoznacznie określonym typie, które są zoptymalizowane pod kątem naszych scenariuszy widoku, i które uwidaczniają właściwości wartości dynamicznych/zawartości wymaganej przez nasze szablony widoków.</span><span class="sxs-lookup"><span data-stu-id="80619-142">When using this pattern we create strongly-typed classes that are optimized for our specific view scenarios, and which expose properties for the dynamic values/content needed by our view templates.</span></span> <span data-ttu-id="80619-143">Nasze klasy kontrolera mogą następnie wypełnić i przekazać te klasy zoptymalizowane pod kątem widoku do naszego szablonu widoku.</span><span class="sxs-lookup"><span data-stu-id="80619-143">Our controller classes can then populate and pass these view-optimized classes to our view template to use.</span></span> <span data-ttu-id="80619-144">Zapewnia to bezpieczeństwo typu, sprawdzanie czasu kompilacji i IntelliSense w edytorze w szablonach widoków.</span><span class="sxs-lookup"><span data-stu-id="80619-144">This enables type-safety, compile-time checking, and editor intellisense within view templates.</span></span>

<span data-ttu-id="80619-145">Na przykład, aby włączyć scenariusze edytowania formularza obiadu, możemy utworzyć klasę "DinnerFormViewModel", jak poniżej, która uwidacznia dwie właściwości o jednoznacznie określonym typie: obiekt obiadu i model SelectList, który jest wymagany do wypełnienia krajów DropDownList:</span><span class="sxs-lookup"><span data-stu-id="80619-145">For example, to enable dinner form editing scenarios we can create a "DinnerFormViewModel" class like below that exposes two strongly-typed properties: a Dinner object, and the SelectList model needed to populate the countries dropdownlist:</span></span>

[!code-csharp[Main](use-viewdata-and-implement-viewmodel-classes/samples/sample4.cs)]

<span data-ttu-id="80619-146">Następnie możemy zaktualizować metodę akcji Edit () w celu utworzenia DinnerFormViewModel przy użyciu obiektu obiadu, który pobieramy z naszego repozytorium, a następnie przekazać go do naszego szablonu widoku:</span><span class="sxs-lookup"><span data-stu-id="80619-146">We can then update our Edit() action method to create the DinnerFormViewModel using the Dinner object we retrieve from our repository, and then pass it to our view template:</span></span>

[!code-csharp[Main](use-viewdata-and-implement-viewmodel-classes/samples/sample5.cs)]

<span data-ttu-id="80619-147">Następnie zaktualizujemy nasz szablon widoku tak, aby oczekiwał "DinnerFormViewModel" zamiast obiektu "obiad", zmieniając atrybut "Inherits" w górnej części strony Edit. aspx, na przykład:</span><span class="sxs-lookup"><span data-stu-id="80619-147">We'll then update our view template so that it expects a "DinnerFormViewModel" instead of a "Dinner" object by changing the "inherits" attribute at the top of the edit.aspx page like so:</span></span>

[!code-cshtml[Main](use-viewdata-and-implement-viewmodel-classes/samples/sample6.cshtml)]

<span data-ttu-id="80619-148">Po wykonaniu tej czynności funkcja IntelliSense właściwości "model" w naszym szablonie widoku zostanie zaktualizowana w celu odzwierciedlenia modelu obiektów typu DinnerFormViewModel, który przekazujemy:</span><span class="sxs-lookup"><span data-stu-id="80619-148">Once we do this, the intellisense of the "Model" property within our view template will be updated to reflect the object model of the DinnerFormViewModel type we are passing it:</span></span>

![](use-viewdata-and-implement-viewmodel-classes/_static/image2.png)

![](use-viewdata-and-implement-viewmodel-classes/_static/image3.png)

<span data-ttu-id="80619-149">Następnie możemy zaktualizować nasz kod widoku, aby go wycofać.</span><span class="sxs-lookup"><span data-stu-id="80619-149">We can then update our view code to work off of it.</span></span> <span data-ttu-id="80619-150">Zwróć uwagę na to, jak nie zmieniamy nazw elementów wejściowych, które tworzysz (elementy formularza będą nadal nazywane "tytułem", "kraj"), ale aktualizujemy metody pomocników HTML w celu pobrania wartości przy użyciu klasy DinnerFormViewModel:</span><span class="sxs-lookup"><span data-stu-id="80619-150">Notice below how we are not changing the names of the input elements we are creating (the form elements will still be named "Title", "Country") – but we are updating the HTML Helper methods to retrieve the values using the DinnerFormViewModel class:</span></span>

[!code-aspx[Main](use-viewdata-and-implement-viewmodel-classes/samples/sample7.aspx)]

<span data-ttu-id="80619-151">Zaktualizujemy również nasze metody edycji post, aby używać klasy DinnerFormViewModel podczas renderowania błędów:</span><span class="sxs-lookup"><span data-stu-id="80619-151">We'll also update our Edit post method to use the DinnerFormViewModel class when rendering errors:</span></span>

[!code-csharp[Main](use-viewdata-and-implement-viewmodel-classes/samples/sample8.cs)]

<span data-ttu-id="80619-152">Możemy również zaktualizować nasze metody akcji Create (), aby ponownie użyć dokładnie tej samej klasy *DinnerFormViewModel* , aby umożliwić krajom DropDownList w tych krajach.</span><span class="sxs-lookup"><span data-stu-id="80619-152">We can also update our Create() action methods to re-use the exact same *DinnerFormViewModel* class to enable the countries DropDownList within those as well.</span></span> <span data-ttu-id="80619-153">Poniżej znajduje się implementacja protokołu HTTP-GET:</span><span class="sxs-lookup"><span data-stu-id="80619-153">Below is the HTTP-GET implementation:</span></span>

[!code-csharp[Main](use-viewdata-and-implement-viewmodel-classes/samples/sample9.cs)]

<span data-ttu-id="80619-154">Poniżej znajduje się implementacja metody Create protokołu HTTP-POST:</span><span class="sxs-lookup"><span data-stu-id="80619-154">Below is the implementation of the HTTP-POST Create method:</span></span>

[!code-csharp[Main](use-viewdata-and-implement-viewmodel-classes/samples/sample10.cs)]

<span data-ttu-id="80619-155">Teraz zarówno nasze ekrany edycji, jak i tworzenie obsługują downlists do wybierania kraju.</span><span class="sxs-lookup"><span data-stu-id="80619-155">And now both our Edit and Create screens support drop-downlists for picking the country.</span></span>

### <a name="custom-shaped-viewmodel-classes"></a><span data-ttu-id="80619-156">Niestandardowe klasy ViewModel</span><span class="sxs-lookup"><span data-stu-id="80619-156">Custom-shaped ViewModel classes</span></span>

<span data-ttu-id="80619-157">W powyższym scenariuszu Klasa DinnerFormViewModel bezpośrednio ujawnia obiekt modelu obiadu jako właściwość wraz z właściwością SelectList model.</span><span class="sxs-lookup"><span data-stu-id="80619-157">In the scenario above, our DinnerFormViewModel class directly exposes the Dinner model object as a property, along with a supporting SelectList model property.</span></span> <span data-ttu-id="80619-158">Takie podejście działa prawidłowo w przypadku scenariuszy, w których interfejs użytkownika HTML, który chcemy utworzyć w naszym szablonie widoku, odpowiada stosunkowo ścisłemu obiektowi modelu domeny.</span><span class="sxs-lookup"><span data-stu-id="80619-158">This approach works fine for scenarios where the HTML UI we want to create within our view template corresponds relatively closely to our domain model objects.</span></span>

<span data-ttu-id="80619-159">W przypadku scenariuszy, w których nie jest to przypadek, jedną z opcji, której można użyć, jest utworzenie klasy ViewModel o kształcie niestandardowym, której model obiektów jest bardziej zoptymalizowany do użycia przez widok — i który może wyglądać zupełnie inaczej od obiektu modelu domeny.</span><span class="sxs-lookup"><span data-stu-id="80619-159">For scenarios where this isn't the case, one option that you can use is to create a custom-shaped ViewModel class whose object model is more optimized for consumption by the view – and which might look completely different from the underlying domain model object.</span></span> <span data-ttu-id="80619-160">Na przykład może potencjalnie uwidocznić różne nazwy właściwości i/lub zagregowane właściwości zebrane z wielu obiektów modelu.</span><span class="sxs-lookup"><span data-stu-id="80619-160">For example, it could potentially expose different property names and/or aggregate properties collected from multiple model objects.</span></span>

<span data-ttu-id="80619-161">Klasy ViewModel w kształcie niestandardowym mogą być używane zarówno do przekazywania danych z kontrolerów do widoków do renderowania, jak i do obsługi danych formularza opublikowanych z powrotem do metody akcji kontrolera.</span><span class="sxs-lookup"><span data-stu-id="80619-161">Custom-shaped ViewModel classes can be used both to pass data from controllers to views to render, as well as to help handle form data posted back to a controller's action method.</span></span> <span data-ttu-id="80619-162">W tym późniejszym scenariuszu może istnieć Metoda akcji aktualizująca obiekt ViewModel z danymi opublikowanymi w formie, a następnie użycie wystąpienia ViewModel w celu zamapowania lub pobrania rzeczywistego obiektu modelu domeny.</span><span class="sxs-lookup"><span data-stu-id="80619-162">For this later scenario, you might have the action method update a ViewModel object with the form-posted data, and then use the ViewModel instance to map or retrieve an actual domain model object.</span></span>

<span data-ttu-id="80619-163">Klasy ViewModel w kształcie niestandardowym mogą zapewniać dużą elastyczność i są coś do zbadania dowolnego czasu, aby znaleźć kod renderowania w szablonach widoku lub kod post formularza wewnątrz metod akcji, rozpoczynając od zbyt skomplikowanego.</span><span class="sxs-lookup"><span data-stu-id="80619-163">Custom-shaped ViewModel classes can provide a great deal of flexibility, and are something to investigate any time you find the rendering code within your view templates or the form-posting code inside your action methods starting to get too complicated.</span></span> <span data-ttu-id="80619-164">Jest to często znak, który nie odpowiada Twoim modelom domeny w sposób niewidoczny dla generowanego interfejsu użytkownika i że pośrednia niestandardowa Klasa ViewModel może pomóc.</span><span class="sxs-lookup"><span data-stu-id="80619-164">This is often a sign that your domain models don't cleanly correspond to the UI you are generating, and that an intermediate custom-shaped ViewModel class can help.</span></span>

### <a name="next-step"></a><span data-ttu-id="80619-165">Następny krok</span><span class="sxs-lookup"><span data-stu-id="80619-165">Next Step</span></span>

<span data-ttu-id="80619-166">Teraz przyjrzyjmy się sposobom używania częściowych i stron głównych do ponownego użycia i udostępnienia interfejsu użytkownika w naszej aplikacji.</span><span class="sxs-lookup"><span data-stu-id="80619-166">Let's now look at how we can use partials and master-pages to re-use and share UI across our application.</span></span>

> [!div class="step-by-step"]
> <span data-ttu-id="80619-167">[Poprzednie](provide-crud-create-read-update-delete-data-form-entry-support.md)
> [dalej](re-use-ui-using-master-pages-and-partials.md)</span><span class="sxs-lookup"><span data-stu-id="80619-167">[Previous](provide-crud-create-read-update-delete-data-form-entry-support.md)
[Next](re-use-ui-using-master-pages-and-partials.md)</span></span>
