---
uid: web-api/overview/security/preventing-cross-site-request-forgery-csrf-attacks
title: Zapobieganie atakom w ramach żądania krzyżowego (CSRF) w ASP.NET MVC
author: MikeWasson
description: Opisuje atak między lokacjami (CSRF) i sposób wdrażania miar antyCSRFowych w ASP.NET Web MVC.
ms.author: riande
ms.date: 12/12/2012
ms.assetid: 81d46f14-8f48-4d8c-830d-cc8d594dc11b
msc.legacyurl: /web-api/overview/security/preventing-cross-site-request-forgery-csrf-attacks
msc.type: authoredcontent
ms.openlocfilehash: 5fb0f8bcc9e587ba4fbbf2b857d3bf7adcaafb94
ms.sourcegitcommit: e7e91932a6e91a63e2e46417626f39d6b244a3ab
ms.translationtype: MT
ms.contentlocale: pl-PL
ms.lasthandoff: 03/06/2020
ms.locfileid: "78555119"
---
# <a name="preventing-cross-site-request-forgery-csrf-attacks-in-aspnet-mvc-application"></a><span data-ttu-id="e5dca-103">Zapobieganie atakom przez wiele witryn (CSRF) w aplikacji ASP.NET MVC</span><span class="sxs-lookup"><span data-stu-id="e5dca-103">Preventing Cross-Site Request Forgery (CSRF) Attacks in ASP.NET MVC Application</span></span>

<span data-ttu-id="e5dca-104">według [Jan Wasson](https://github.com/MikeWasson)</span><span class="sxs-lookup"><span data-stu-id="e5dca-104">by [Mike Wasson](https://github.com/MikeWasson)</span></span>

<span data-ttu-id="e5dca-105">Fałszerstwo żądania między lokacjami (CSRF) to atak polegający na tym, że złośliwa witryna wysyła żądanie do zagrożonej lokacji, w której użytkownik jest aktualnie zalogowany.</span><span class="sxs-lookup"><span data-stu-id="e5dca-105">Cross-Site Request Forgery (CSRF) is an attack where a malicious site sends a request to a vulnerable site where the user is currently logged in</span></span>

<span data-ttu-id="e5dca-106">Oto przykład ataku CSRF:</span><span class="sxs-lookup"><span data-stu-id="e5dca-106">Here is an example of a CSRF attack:</span></span>

1. <span data-ttu-id="e5dca-107">Użytkownik loguje się do `www.example.com` przy użyciu uwierzytelniania formularzy.</span><span class="sxs-lookup"><span data-stu-id="e5dca-107">A user logs into `www.example.com` using forms authentication.</span></span>
2. <span data-ttu-id="e5dca-108">Serwer uwierzytelnia użytkownika.</span><span class="sxs-lookup"><span data-stu-id="e5dca-108">The server authenticates the user.</span></span> <span data-ttu-id="e5dca-109">Odpowiedź z serwera zawiera plik cookie uwierzytelniania.</span><span class="sxs-lookup"><span data-stu-id="e5dca-109">The response from the server includes an authentication cookie.</span></span>
3. <span data-ttu-id="e5dca-110">Bez wylogowywania użytkownik odwiedza złośliwą witrynę sieci Web.</span><span class="sxs-lookup"><span data-stu-id="e5dca-110">Without logging out, the user visits a malicious web site.</span></span> <span data-ttu-id="e5dca-111">Ta złośliwa witryna zawiera następującą postać HTML:</span><span class="sxs-lookup"><span data-stu-id="e5dca-111">This malicious site contains the following HTML form:</span></span> 

    [!code-html[Main](preventing-cross-site-request-forgery-csrf-attacks/samples/sample1.html)]

    <span data-ttu-id="e5dca-112">Należy zauważyć, że w ramach akcji formularza są umieszczane wpisy w zagrożonej witrynie, a nie w złośliwej witrynie.</span><span class="sxs-lookup"><span data-stu-id="e5dca-112">Notice that the form action posts to the vulnerable site, not to the malicious site.</span></span> <span data-ttu-id="e5dca-113">To jest część "wiele witryn" z CSRF.</span><span class="sxs-lookup"><span data-stu-id="e5dca-113">This is the "cross-site" part of CSRF.</span></span>
4. <span data-ttu-id="e5dca-114">Użytkownik klika przycisk Prześlij.</span><span class="sxs-lookup"><span data-stu-id="e5dca-114">The user clicks the submit button.</span></span> <span data-ttu-id="e5dca-115">Przeglądarka zawiera plik cookie uwierzytelniania z żądaniem.</span><span class="sxs-lookup"><span data-stu-id="e5dca-115">The browser includes the authentication cookie with the request.</span></span>
5. <span data-ttu-id="e5dca-116">Żądanie jest uruchamiane na serwerze z kontekstem uwierzytelniania użytkownika i może wykonywać wszystkie czynności, które mogą wykonać uwierzytelnionego użytkownika.</span><span class="sxs-lookup"><span data-stu-id="e5dca-116">The request runs on the server with the user's authentication context, and can do anything that an authenticated user is allowed to do.</span></span>

<span data-ttu-id="e5dca-117">Mimo że ten przykład wymaga, aby użytkownik klikał przycisk formularza, złośliwa strona może tak jak łatwo uruchomić skrypt, który przesyła formularz automatycznie.</span><span class="sxs-lookup"><span data-stu-id="e5dca-117">Although this example requires the user to click the form button, the malicious page could just as easily run a script that submits the form automatically.</span></span> <span data-ttu-id="e5dca-118">Ponadto użycie protokołu SSL nie uniemożliwia ataku CSRF, ponieważ złośliwa witryna może wysłać żądanie "https://".</span><span class="sxs-lookup"><span data-stu-id="e5dca-118">Moreover, using SSL does not prevent a CSRF attack, because the malicious site can send an "https://" request.</span></span>

<span data-ttu-id="e5dca-119">Zazwyczaj ataki CSRF są dostępne dla witryn sieci Web, które używają plików cookie do uwierzytelniania, ponieważ przeglądarki wysyłają wszystkie odpowiednie pliki cookie do docelowej witryny sieci Web.</span><span class="sxs-lookup"><span data-stu-id="e5dca-119">Typically, CSRF attacks are possible against web sites that use cookies for authentication, because browsers send all relevant cookies to the destination web site.</span></span> <span data-ttu-id="e5dca-120">Jednak ataki CSRF nie ograniczają się do korzystania z plików cookie.</span><span class="sxs-lookup"><span data-stu-id="e5dca-120">However, CSRF attacks are not limited to exploiting cookies.</span></span> <span data-ttu-id="e5dca-121">Na przykład uwierzytelnianie podstawowe i szyfrowane jest również zagrożone.</span><span class="sxs-lookup"><span data-stu-id="e5dca-121">For example, Basic and Digest authentication are also vulnerable.</span></span> <span data-ttu-id="e5dca-122">Po zalogowaniu się użytkownika przy użyciu uwierzytelniania podstawowego lub szyfrowanego.</span><span class="sxs-lookup"><span data-stu-id="e5dca-122">After a user logs in with Basic or Digest authentication.</span></span> <span data-ttu-id="e5dca-123">Przeglądarka automatycznie wysyła poświadczenia do momentu zakończenia sesji.</span><span class="sxs-lookup"><span data-stu-id="e5dca-123">the browser automatically sends the credentials until the session ends.</span></span>

## <a name="anti-forgery-tokens"></a><span data-ttu-id="e5dca-124">Tokeny zabezpieczające przed fałszerstwem</span><span class="sxs-lookup"><span data-stu-id="e5dca-124">Anti-Forgery Tokens</span></span>

<span data-ttu-id="e5dca-125">Aby zapobiec atakom CSRF, ASP.NET MVC używa tokenów chroniących przed fałszerstwem, nazywanych również *tokenami weryfikacji żądań*.</span><span class="sxs-lookup"><span data-stu-id="e5dca-125">To help prevent CSRF attacks, ASP.NET MVC uses anti-forgery tokens, also called *request verification tokens*.</span></span>

1. <span data-ttu-id="e5dca-126">Klient żąda strony HTML zawierającej formularz.</span><span class="sxs-lookup"><span data-stu-id="e5dca-126">The client requests an HTML page that contains a form.</span></span>
2. <span data-ttu-id="e5dca-127">Serwer zawiera dwa tokeny w odpowiedzi.</span><span class="sxs-lookup"><span data-stu-id="e5dca-127">The server includes two tokens in the response.</span></span> <span data-ttu-id="e5dca-128">Jeden token jest wysyłany jako plik cookie.</span><span class="sxs-lookup"><span data-stu-id="e5dca-128">One token is sent as a cookie.</span></span> <span data-ttu-id="e5dca-129">Druga zostanie umieszczona w ukrytym polu formularza.</span><span class="sxs-lookup"><span data-stu-id="e5dca-129">The other is placed in a hidden form field.</span></span> <span data-ttu-id="e5dca-130">Tokeny są generowane losowo, dzięki czemu element atakującej nie może odgadnąć wartości.</span><span class="sxs-lookup"><span data-stu-id="e5dca-130">The tokens are generated randomly so that an adversary cannot guess the values.</span></span>
3. <span data-ttu-id="e5dca-131">Gdy klient prześle formularz, musi wysłać oba tokeny z powrotem do serwera.</span><span class="sxs-lookup"><span data-stu-id="e5dca-131">When the client submits the form, it must send both tokens back to the server.</span></span> <span data-ttu-id="e5dca-132">Klient wysyła token cookie jako plik cookie i wysyła token formularza wewnątrz danych formularza.</span><span class="sxs-lookup"><span data-stu-id="e5dca-132">The client sends the cookie token as a cookie, and it sends the form token inside the form data.</span></span> <span data-ttu-id="e5dca-133">(Klient przeglądarki automatycznie robi to podczas przesyłania formularza przez użytkownika).</span><span class="sxs-lookup"><span data-stu-id="e5dca-133">(A browser client automatically does this when the user submits the form.)</span></span>
4. <span data-ttu-id="e5dca-134">Jeśli żądanie nie zawiera obu tokenów, serwer nie zezwala na żądanie.</span><span class="sxs-lookup"><span data-stu-id="e5dca-134">If a request does not include both tokens, the server disallows the request.</span></span>

<span data-ttu-id="e5dca-135">Oto przykład formularza HTML z tokenem ukrytego formularza:</span><span class="sxs-lookup"><span data-stu-id="e5dca-135">Here is an example of an HTML form with a hidden form token:</span></span>

[!code-html[Main](preventing-cross-site-request-forgery-csrf-attacks/samples/sample2.html)]

<span data-ttu-id="e5dca-136">Tokeny chroniące przed fałszerstwem działają, ponieważ złośliwa strona nie może odczytać tokenów użytkownika ze względu na zasady tego samego źródła.</span><span class="sxs-lookup"><span data-stu-id="e5dca-136">Anti-forgery tokens work because the malicious page cannot read the user's tokens, due to same-origin policies.</span></span> <span data-ttu-id="e5dca-137">([Zasady tego samego pochodzenia](http://www.w3.org/Security/wiki/Same_Origin_Policy) uniemożliwiają dokumentom hostowanym w dwóch różnych lokacjach dostęp do każdej z nich.</span><span class="sxs-lookup"><span data-stu-id="e5dca-137">([Same-origin policies](http://www.w3.org/Security/wiki/Same_Origin_Policy) prevent documents hosted on two different sites from accessing each other's content.</span></span> <span data-ttu-id="e5dca-138">Tak więc w poprzednim przykładzie złośliwa strona może wysyłać żądania do example.com, ale nie może odczytać odpowiedzi.</span><span class="sxs-lookup"><span data-stu-id="e5dca-138">So in the earlier example, the malicious page can send requests to example.com, but it cannot read the response.)</span></span>

<span data-ttu-id="e5dca-139">Aby zapobiec atakom CSRF, należy użyć tokenów chroniących przed fałszerstwem przy użyciu dowolnego protokołu uwierzytelniania, w którym przeglądarka w trybie dyskretnym wysyła poświadczenia po zalogowaniu się użytkownika.</span><span class="sxs-lookup"><span data-stu-id="e5dca-139">To prevent CSRF attacks, use anti-forgery tokens with any authentication protocol where the browser silently sends credentials after the user logs in.</span></span> <span data-ttu-id="e5dca-140">Dotyczy to protokołów uwierzytelniania opartych na plikach cookie, takich jak uwierzytelnianie formularzy, a także protokołów takich jak uwierzytelnianie podstawowe i szyfrowane.</span><span class="sxs-lookup"><span data-stu-id="e5dca-140">This includes cookie-based authentication protocols, such as forms authentication, as well as protocols such as Basic and Digest authentication.</span></span>

<span data-ttu-id="e5dca-141">Należy wymagać, aby tokeny zabezpieczające przed fałszowaniem były stosowane do wszelkich metod niebezpiecznych (POST, PUT i DELETE).</span><span class="sxs-lookup"><span data-stu-id="e5dca-141">You should require anti-forgery tokens for any nonsafe methods (POST, PUT, DELETE).</span></span> <span data-ttu-id="e5dca-142">Upewnij się również, że metody bezpieczne (GET, główna) nie mają żadnych efektów ubocznych.</span><span class="sxs-lookup"><span data-stu-id="e5dca-142">Also, make sure that safe methods (GET, HEAD) do not have any side effects.</span></span> <span data-ttu-id="e5dca-143">Ponadto, jeśli włączysz obsługę międzydomenową, taką jak CORS lub JSONP, to nawet bezpieczne metody, takie jak GET, potencjalnie narażony na ataki CSRF, umożliwiając atakującemu odczytywanie potencjalnie poufnych danych.</span><span class="sxs-lookup"><span data-stu-id="e5dca-143">Moreover, if you enable cross-domain support, such as CORS or JSONP, then even safe methods like GET are potentially vulnerable to CSRF attacks, allowing the attacker to read potentially sensitive data.</span></span>

## <a name="anti-forgery-tokens-in-aspnet-mvc"></a><span data-ttu-id="e5dca-144">Tokeny chroniące przed fałszowaniem w ASP.NET MVC</span><span class="sxs-lookup"><span data-stu-id="e5dca-144">Anti-Forgery Tokens in ASP.NET MVC</span></span>

<span data-ttu-id="e5dca-145">Aby dodać tokeny chroniące przed fałszerstwem do strony Razor, użyj metody pomocnika **HtmlHelper. AntiForgeryToken** :</span><span class="sxs-lookup"><span data-stu-id="e5dca-145">To add the anti-forgery tokens to a Razor page, use the **HtmlHelper.AntiForgeryToken** helper method:</span></span>

[!code-cshtml[Main](preventing-cross-site-request-forgery-csrf-attacks/samples/sample3.cshtml)]

<span data-ttu-id="e5dca-146">Ta metoda dodaje ukryte pole formularza, a także ustawia token cookie.</span><span class="sxs-lookup"><span data-stu-id="e5dca-146">This method adds the hidden form field and also sets the cookie token.</span></span>

## <a name="anti-csrf-and-ajax"></a><span data-ttu-id="e5dca-147">Anti-CSRF i AJAX</span><span class="sxs-lookup"><span data-stu-id="e5dca-147">Anti-CSRF and AJAX</span></span>

<span data-ttu-id="e5dca-148">Token formularza może stanowić problem z żądaniami AJAX, ponieważ żądanie AJAX może wysyłać dane JSON, a nie dane formularza HTML.</span><span class="sxs-lookup"><span data-stu-id="e5dca-148">The form token can be a problem for AJAX requests, because an AJAX request might send JSON data, not HTML form data.</span></span> <span data-ttu-id="e5dca-149">Jednym z rozwiązań jest wysłanie tokenów w niestandardowym nagłówku HTTP.</span><span class="sxs-lookup"><span data-stu-id="e5dca-149">One solution is to send the tokens in a custom HTTP header.</span></span> <span data-ttu-id="e5dca-150">Poniższy kod używa składnia Razor do wygenerowania tokenów, a następnie dodaje tokeny do żądania AJAX.</span><span class="sxs-lookup"><span data-stu-id="e5dca-150">The following code uses Razor syntax to generate the tokens, and then adds the tokens to an AJAX request.</span></span> <span data-ttu-id="e5dca-151">Tokeny są generowane na serwerze przez wywołanie funkcji " **Gettokens**".</span><span class="sxs-lookup"><span data-stu-id="e5dca-151">The tokens are generated at the server by calling **AntiForgery.GetTokens**.</span></span>

[!code-html[Main](preventing-cross-site-request-forgery-csrf-attacks/samples/sample4.html)]

<span data-ttu-id="e5dca-152">Podczas przetwarzania żądania Wyodrębnij tokeny z nagłówka żądania.</span><span class="sxs-lookup"><span data-stu-id="e5dca-152">When you process the request, extract the tokens from the request header.</span></span> <span data-ttu-id="e5dca-153">Następnie Wywołaj metodę **Unfałszerstwa. Validate** , aby sprawdzić poprawność tokenów.</span><span class="sxs-lookup"><span data-stu-id="e5dca-153">Then call the **AntiForgery.Validate** method to validate the tokens.</span></span> <span data-ttu-id="e5dca-154">Metoda **Validate** zgłasza wyjątek, jeśli tokeny są nieprawidłowe.</span><span class="sxs-lookup"><span data-stu-id="e5dca-154">The **Validate** method throws an exception if the tokens are not valid.</span></span>

[!code-csharp[Main](preventing-cross-site-request-forgery-csrf-attacks/samples/sample5.cs)]
