---
title: Wyłączanie ochrony ładunków, których klucze zostały odwołane w programie ASP.NET Core
author: rick-anderson
description: Dowiedz się, jak wyłączyć ochronę danych, chronione przy użyciu kluczy, które od zostały odwołane, w aplikacji ASP.NET Core.
ms.author: riande
ms.custom: mvc
ms.date: 10/24/2018
uid: security/data-protection/consumer-apis/dangerous-unprotect
ms.openlocfilehash: b93ab0fa650041afdfaf1ed5572cc7e081bba244
ms.sourcegitcommit: 24b1f6decbb17bb22a45166e5fdb0845c65af498
ms.translationtype: MT
ms.contentlocale: pl-PL
ms.lasthandoff: 03/01/2019
ms.locfileid: "57077510"
---
# <a name="unprotect-payloads-whose-keys-have-been-revoked-in-aspnet-core"></a><span data-ttu-id="dd944-103">Wyłączanie ochrony ładunków, których klucze zostały odwołane w programie ASP.NET Core</span><span class="sxs-lookup"><span data-stu-id="dd944-103">Unprotect payloads whose keys have been revoked in ASP.NET Core</span></span>


<a name="data-protection-consumer-apis-dangerous-unprotect"></a>

<span data-ttu-id="dd944-104">Interfejsy API ochrony danych programu ASP.NET Core nie są przeznaczone głównie dla nieokreślony stan trwały ładunki poufne.</span><span class="sxs-lookup"><span data-stu-id="dd944-104">The ASP.NET Core data protection APIs are not primarily intended for indefinite persistence of confidential payloads.</span></span> <span data-ttu-id="dd944-105">Inne technologie, takie jak [Windows CNG DPAPI](https://msdn.microsoft.com/library/windows/desktop/hh706794%28v=vs.85%29.aspx) i [usługi Azure Rights Management](/rights-management/) są bardziej odpowiednie do scenariusza nieograniczony magazyn i mają możliwości odpowiednio silne zarządzania kluczami.</span><span class="sxs-lookup"><span data-stu-id="dd944-105">Other technologies like [Windows CNG DPAPI](https://msdn.microsoft.com/library/windows/desktop/hh706794%28v=vs.85%29.aspx) and [Azure Rights Management](/rights-management/) are more suited to the scenario of indefinite storage, and they have correspondingly strong key management capabilities.</span></span> <span data-ttu-id="dd944-106">Inaczej mówiąc, nic nie uniemożliwiają dewelopera przy użyciu platformy ASP.NET Core interfejsy API ochrony danych dla długoterminowej ochrony poufnych danych.</span><span class="sxs-lookup"><span data-stu-id="dd944-106">That said, there's nothing prohibiting a developer from using the ASP.NET Core data protection APIs for long-term protection of confidential data.</span></span> <span data-ttu-id="dd944-107">Klucze nie są nigdy usuwane z pierścienia klucza, więc `IDataProtector.Unprotect` zawsze można odzyskać istniejących ładunków, tak długo, jak klucze są dostępne i prawidłowy.</span><span class="sxs-lookup"><span data-stu-id="dd944-107">Keys are never removed from the key ring, so `IDataProtector.Unprotect` can always recover existing payloads as long as the keys are available and valid.</span></span>

<span data-ttu-id="dd944-108">Jednak problem pojawia się podczas wyłączania ochrony danych, który został objęty ochroną za pomocą klucza odwołane, jako deweloper `IDataProtector.Unprotect` spowoduje zgłoszenie wyjątku w tym przypadku.</span><span class="sxs-lookup"><span data-stu-id="dd944-108">However, an issue arises when the developer tries to unprotect data that has been protected with a revoked key, as `IDataProtector.Unprotect` will throw an exception in this case.</span></span> <span data-ttu-id="dd944-109">Może to być dobrym rozwiązaniem dla ładunków krótkotrwałe lub przejściowe (na przykład tokeny uwierzytelniania), jak można łatwo odtworzyć te rodzaje ładunków w przez system, a w najgorszym przypadku użytkownik może być konieczne ponowne zalogowanie.</span><span class="sxs-lookup"><span data-stu-id="dd944-109">This might be fine for short-lived or transient payloads (like authentication tokens), as these kinds of payloads can easily be recreated by the system, and at worst the site visitor might be required to log in again.</span></span> <span data-ttu-id="dd944-110">Ale utrwalonych ładunków, mających `Unprotect` throw może prowadzić do utraty danych nie do przyjęcia.</span><span class="sxs-lookup"><span data-stu-id="dd944-110">But for persisted payloads, having `Unprotect` throw could lead to unacceptable data loss.</span></span>

## <a name="ipersisteddataprotector"></a><span data-ttu-id="dd944-111">IPersistedDataProtector</span><span class="sxs-lookup"><span data-stu-id="dd944-111">IPersistedDataProtector</span></span>

<span data-ttu-id="dd944-112">Aby móc obsługiwać scenariusz umożliwienia ładunki do usunięcia ochrony nawet w przypadku odwołanego kluczy, system ochrony danych zawiera `IPersistedDataProtector` typu.</span><span class="sxs-lookup"><span data-stu-id="dd944-112">To support the scenario of allowing payloads to be unprotected even in the face of revoked keys, the data protection system contains an `IPersistedDataProtector` type.</span></span> <span data-ttu-id="dd944-113">Aby pobrać wystąpienie obiektu `IPersistedDataProtector`, wystarczy pobrać wystąpienie obiektu `IDataProtector` w normalny sposób i spróbuj wykonać rzutowanie `IDataProtector` do `IPersistedDataProtector`.</span><span class="sxs-lookup"><span data-stu-id="dd944-113">To get an instance of `IPersistedDataProtector`, simply get an instance of `IDataProtector` in the normal fashion and try casting the `IDataProtector` to `IPersistedDataProtector`.</span></span>

> [!NOTE]
> <span data-ttu-id="dd944-114">Nie wszystkie `IDataProtector` wystąpienia mogą być rzutowane na `IPersistedDataProtector`.</span><span class="sxs-lookup"><span data-stu-id="dd944-114">Not all `IDataProtector` instances can be cast to `IPersistedDataProtector`.</span></span> <span data-ttu-id="dd944-115">Programiści powinni używać C# jako operator lub podobne w celu uniknięcia wyjątki środowiska uruchomieniowego spowodowane przez nieprawidłowy rzutowania i powinna być przygotowana do obsługi w przypadku niepowodzenia odpowiednio.</span><span class="sxs-lookup"><span data-stu-id="dd944-115">Developers should use the C# as operator or similar to avoid runtime exceptions caused by invalid casts, and they should be prepared to handle the failure case appropriately.</span></span>

<span data-ttu-id="dd944-116">`IPersistedDataProtector` udostępnia następujące powierzchni interfejsu API:</span><span class="sxs-lookup"><span data-stu-id="dd944-116">`IPersistedDataProtector` exposes the following API surface:</span></span>

```csharp
DangerousUnprotect(byte[] protectedData, bool ignoreRevocationErrors,
     out bool requiresMigration, out bool wasRevoked) : byte[]
```

<span data-ttu-id="dd944-117">Ten interfejs API przyjmuje chronionych ładunek (w postaci tablicy bajtów) i zwraca ładunek niechronione.</span><span class="sxs-lookup"><span data-stu-id="dd944-117">This API takes the protected payload (as a byte array) and returns the unprotected payload.</span></span> <span data-ttu-id="dd944-118">Nie istnieje żadne przeciążenie oparte na ciągach.</span><span class="sxs-lookup"><span data-stu-id="dd944-118">There's no string-based overload.</span></span> <span data-ttu-id="dd944-119">Poniżej znajdują się dwa parametry wyjściowe.</span><span class="sxs-lookup"><span data-stu-id="dd944-119">The two out parameters are as follows.</span></span>

* <span data-ttu-id="dd944-120">`requiresMigration`: ustawionej na wartość true, jeśli klucz używany do ochrony ten ładunek nie jest już aktywna domyślny klucz, np. klucz używany do ochrony ten ładunek jest stary i kluczem operację stopniowego od tego czasu, wpłynie miejsce.</span><span class="sxs-lookup"><span data-stu-id="dd944-120">`requiresMigration`: will be set to true if the key used to protect this payload is no longer the active default key, e.g., the key used to protect this payload is old and a key rolling operation has since taken place.</span></span> <span data-ttu-id="dd944-121">Obiekt wywołujący może chcieć należy wziąć pod uwagę ponowne włączanie ochrony ładunek, w zależności od swoich potrzeb biznesowych.</span><span class="sxs-lookup"><span data-stu-id="dd944-121">The caller may wish to consider reprotecting the payload depending on their business needs.</span></span>

* <span data-ttu-id="dd944-122">`wasRevoked`: zostanie ustawiony na wartość true, jeśli klucz używany do ochrony ten ładunek został odwołany.</span><span class="sxs-lookup"><span data-stu-id="dd944-122">`wasRevoked`: will be set to true if the key used to protect this payload was revoked.</span></span>

>[!WARNING]
> <span data-ttu-id="dd944-123">Zachować wyjątkową ostrożność podczas przekazywania `ignoreRevocationErrors: true` do `DangerousUnprotect` metody.</span><span class="sxs-lookup"><span data-stu-id="dd944-123">Exercise extreme caution when passing `ignoreRevocationErrors: true` to the `DangerousUnprotect` method.</span></span> <span data-ttu-id="dd944-124">Jeśli po wywołaniu tej metody `wasRevoked` ma wartość true, a następnie klucz używany do ochrony ten ładunek został odwołany i autentyczności ładunku powinny być traktowane jako podejrzana.</span><span class="sxs-lookup"><span data-stu-id="dd944-124">If after calling this method the `wasRevoked` value is true, then the key used to protect this payload was revoked, and the payload's authenticity should be treated as suspect.</span></span> <span data-ttu-id="dd944-125">W tym przypadku tylko kontynuować wykonywanie operacji na niechronionych ładunku w przypadku niektórych oddzielne pewność, że jej są autentyczne, np. że pochodzi z bezpiecznej bazie danych, a nie są wysyłane przez niezaufane sieci web klienta.</span><span class="sxs-lookup"><span data-stu-id="dd944-125">In this case, only continue operating on the unprotected payload if you have some separate assurance that it's authentic, e.g. that it's coming from a secure database rather than being sent by an untrusted web client.</span></span>

[!code-csharp[](dangerous-unprotect/samples/dangerous-unprotect.cs)]
